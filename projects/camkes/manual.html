<!DOCTYPE html>
<!-- Page last generated 2025-08-05 03:47:22 +0000 -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CAmkES Manual | seL4 docs</title>

    <link rel="canonical" href="https://docs.sel4.systems/projects/camkes/manual.html">
    <link href="/assets/css/sel4.css?v=1754365642" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico">

    <script defer src="/assets/js/menu.js"></script>
    <script defer src="/assets/js/sidebar.js"></script><script defer data-domain="docs.sel4.systems"
            src="https://analytics.sel4.systems/js/script.js"></script></head>
  <body class="flex flex-row h-screen std-bg text-dark">
    <div id="sidebar" class="hidden lg:flex flex-none w-(--sidebar-width) flex-row bg-f_neutral-50 dark:bg-gray-900">
      <div class="flex-1 overflow-y-auto min-h-full">
        <a href="/">
  <svg xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" width="84.224365mm" height="32.530689mm" viewBox="0 0 84.224367 32.530689" version="1.1" id="svg5" inkscape:version="1.3.2 (091e20e, 2023-11-25)" sodipodi:docname="sel4-docs.svg" inkscape:export-filename="C:\Users\Birgit Brecknell\Documents\seL4 Foundation\seL4 Summit 2022\sel4_summit_v02.png" inkscape:export-xdpi="96" inkscape:export-ydpi="96" class="px-4 w-50 h-20 mx-auto mt-4 mb-10">
  <sodipodi:namedview id="namedview7" pagecolor="#ffffff" bordercolor="#666666" borderopacity="1.0" inkscape:pageshadow="2" inkscape:pageopacity="0.0" inkscape:pagecheckerboard="0" inkscape:document-units="mm" showgrid="false" inkscape:zoom="1.8116734" inkscape:cx="193.19155" inkscape:cy="87.764163" inkscape:window-width="1392" inkscape:window-height="1099" inkscape:window-x="0" inkscape:window-y="25" inkscape:window-maximized="0" inkscape:current-layer="g18" fit-margin-top="0" fit-margin-left="0" fit-margin-right="0" fit-margin-bottom="0" showguides="true" inkscape:guide-bbox="true" inkscape:showpageshadow="2" inkscape:deskcolor="#d1d1d1"/>
  <defs id="defs2">
    <rect x="680.69342" y="102.26014" width="15.612235" height="115.53054" id="rect9649"/>
    <style id="style824">.cls-1,.cls-2,.cls-3{fill:#96ca4f;}.cls-2,.cls-3{stroke:#96ca4f;stroke-miterlimit:8;}.cls-3{stroke-width:0.25px;}</style>
    <clipPath clipPathUnits="userSpaceOnUse" id="clipPath15">
      <g inkscape:label="Clip" id="use15">
        <path d="m 39.66384,47.73588 h 1.324364 q 0.447983,0 0.68299,0.06854 0.315791,0.09302 0.541007,0.330479 0.225215,0.237455 0.342719,0.582623 0.117503,0.342719 0.117503,0.847005 0,0.443087 -0.110159,0.763774 -0.13464,0.391679 -0.384335,0.63403 -0.188496,0.1836 -0.509183,0.286416 -0.239903,0.07589 -0.641374,0.07589 H 39.66384 Z m 0.724606,0.607103 v 2.377001 h 0.541006 q 0.303551,0 0.438191,-0.03427 0.176255,-0.04406 0.291311,-0.149327 0.117504,-0.105264 0.190944,-0.345168 0.07344,-0.242351 0.07344,-0.65851 0,-0.416159 -0.07344,-0.638926 -0.07344,-0.222767 -0.205632,-0.347615 -0.132192,-0.124848 -0.335375,-0.168912 -0.151776,-0.03427 -0.594862,-0.03427 z m 2.751544,1.209308 q 0,-0.54835 0.164016,-0.920445 0.122399,-0.274175 0.332927,-0.492047 0.212975,-0.217871 0.465118,-0.323135 0.335375,-0.141984 0.773566,-0.141984 0.79315,0 1.268061,0.492047 0.477358,0.492047 0.477358,1.368428 0,0.869038 -0.472462,1.361085 -0.472463,0.489598 -1.263165,0.489598 -0.800494,0 -1.272956,-0.48715 -0.472463,-0.489599 -0.472463,-1.346397 z m 0.746638,-0.02448 q 0,0.609551 0.281519,0.925342 0.281519,0.313343 0.714814,0.313343 0.433295,0 0.709918,-0.310895 0.279072,-0.313343 0.279072,-0.937582 0,-0.616894 -0.271728,-0.920445 -0.269279,-0.303551 -0.717262,-0.303551 -0.447983,0 -0.722158,0.308447 -0.274175,0.305999 -0.274175,0.925341 z m 5.596112,0.477359 0.702574,0.222767 q -0.161567,0.587519 -0.538558,0.873934 -0.374543,0.283967 -0.95227,0.283967 -0.714814,0 -1.175036,-0.48715 -0.460223,-0.489599 -0.460223,-1.336605 0,-0.895965 0.462671,-1.39046 0.46267,-0.496943 1.216652,-0.496943 0.658511,0 1.069773,0.389231 0.2448,0.230112 0.367199,0.660959 l -0.717262,0.171359 q -0.06365,-0.279071 -0.266831,-0.440639 -0.200735,-0.161567 -0.489599,-0.161567 -0.399022,0 -0.648718,0.286415 -0.247247,0.286415 -0.247247,0.927789 0,0.680542 0.244799,0.969406 0.2448,0.288863 0.636478,0.288863 0.288864,0 0.496943,-0.1836 0.20808,-0.183599 0.298655,-0.577726 z m 1.140766,0.151776 0.705022,-0.06854 q 0.06365,0.354959 0.257039,0.521422 0.19584,0.166464 0.526319,0.166464 0.350063,0 0.526318,-0.14688 0.178704,-0.149327 0.178704,-0.347615 0,-0.127295 -0.07589,-0.215423 -0.07344,-0.09058 -0.259487,-0.156672 -0.127296,-0.04406 -0.580175,-0.156671 -0.582622,-0.144432 -0.81763,-0.354959 -0.330479,-0.296208 -0.330479,-0.722158 0,-0.274176 0.154224,-0.511631 0.156671,-0.239903 0.447983,-0.364751 0.293759,-0.124848 0.70747,-0.124848 0.675646,0 1.015917,0.296208 0.342719,0.296207 0.359855,0.790701 l -0.724606,0.03182 q -0.04651,-0.276623 -0.200735,-0.396575 -0.151776,-0.122399 -0.457775,-0.122399 -0.315791,0 -0.494495,0.129743 -0.115056,0.08323 -0.115056,0.222768 0,0.127295 0.107712,0.217871 0.137088,0.115056 0.665854,0.239904 0.528767,0.124847 0.78091,0.259487 0.254591,0.132191 0.396575,0.364751 0.144432,0.230111 0.144432,0.570382 0,0.308447 -0.17136,0.577727 -0.171359,0.269279 -0.484703,0.401471 -0.313343,0.129743 -0.780909,0.129743 -0.680542,0 -1.045293,-0.313343 -0.364751,-0.315791 -0.435743,-0.917997 z" id="path16" style="font-weight:bold;font-stretch:condensed;font-size:5.01349px;font-family:Arial;-inkscape-font-specification:'Arial, Bold Condensed';fill:#96ca4f;stroke-width:0.264583" transform="scale(1.0680757,0.9362632)" aria-label="DOCS"/>
      </g>
    </clipPath>
  </defs>
  <g inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1" transform="translate(-11.065137,-18.670029)">
    <g id="g18">
      <text xml:space="preserve" transform="scale(0.26458333)" id="text9647" style="font-style:normal;font-weight:normal;font-size:40px;line-height:1.25;font-family:sans-serif;white-space:pre;shape-inside:url(#rect9649);display:inline;fill:#000000;fill-opacity:1;stroke:none"/>
      <g id="Layer_2" data-name="Layer 2" transform="matrix(0.5563179,0,0,0.5563179,-0.00218815,0)">
        <path class="cls-1" d="M 169.29,64.52 V 41.46 h -11.1 l -19.38,23.1 h -5.43 v -28.5 h -10.85 v 28.5 h -5.6 c 0,-0.53 0.08,-1.14 0.08,-1.88 V 62 h -6.77 v 1.94 a 6.32,6.32 0 0 1 -0.37,2.63 1.68,1.68 0 0 1 -1.66,0.88 1.5,1.5 0 0 1 -1.42,-0.71 5,5 0 0 1 -0.32,-2.33 V 58.73 H 117 V 56 a 13,13 0 0 0 -0.85,-5.23 6.31,6.31 0 0 0 -2.92,-2.88 11.68,11.68 0 0 0 -5.43,-1.11 11.49,11.49 0 0 0 -4.76,0.93 5.75,5.75 0 0 0 -2.88,2.57 10.54,10.54 0 0 0 -0.89,4.76 v 7 a 20,20 0 0 0 0.13,2.5 h -3 c 0,-0.28 0,-0.56 0,-0.87 a 5.84,5.84 0 0 0 -1,-3.71 12.59,12.59 0 0 0 -4.47,-2.8 22,22 0 0 1 -3.6,-1.84 3,3 0 0 1 -1.22,-1.32 6,6 0 0 1 -0.19,-1.77 2.32,2.32 0 0 1 0.45,-1.52 1.7,1.7 0 0 1 1.39,-0.58 1.5,1.5 0 0 1 1.49,0.71 5.86,5.86 0 0 1 0.25,2.32 v 1.3 h 6.27 V 53 a 11.15,11.15 0 0 0 -0.2,-2.55 3.72,3.72 0 0 0 -1.08,-1.63 6.68,6.68 0 0 0 -2.67,-1.49 14.3,14.3 0 0 0 -4.38,-0.58 13.32,13.32 0 0 0 -4.54,0.71 5,5 0 0 0 -2.63,1.92 7.84,7.84 0 0 0 -0.78,4 6.85,6.85 0 0 0 0.73,3.28 c 0.47,0.89 1.88,1.93 4.17,3.09 3.84,1.92 4.6,2.43 4.85,2.66 a 3.55,3.55 0 0 1 0.59,2.49 3,3 0 0 1 -0.46,2 A 2,2 0 0 1 87.8,67.45 1.5,1.5 0 0 1 86.3,66.6 6.54,6.54 0 0 1 86,63.87 v -2 h -6.29 v 1.62 c 0,0.38 0,0.72 0,1.05 h -6 a 25.58,25.58 0 1 0 0,8.83 H 158 v 8.42 h 11.33 v -8.4 h 5 V 64.52 Z M 38.89,75.1 A 6.1,6.1 0 1 1 45,69 6.1,6.1 0 0 1 38.89,75.1 Z m 67.54,-20.86 a 7.57,7.57 0 0 1 0.24,-2.68 c 0.15,-0.34 0.53,-0.75 1.48,-0.75 a 1.36,1.36 0 0 1 1.35,0.84 7.39,7.39 0 0 1 0.25,2.59 v 2.23 h -3.32 z M 158,64.52 h -9.62 L 158,52.22 Z" transform="translate(-3.04,-2.5)" id="path858"/>
      </g>
      <text xml:space="preserve" style="font-weight:bold;font-stretch:condensed;font-size:8.61839px;font-family:Arial;-inkscape-font-specification:'Arial, Bold Condensed';fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.505292;stroke-opacity:1" x="48.089367" y="45.416836" id="text16" transform="scale(0.93916555,1.064775)"><tspan sodipodi:role="line" id="tspan16" style="fill:#96ca4f;fill-opacity:1;stroke:none;stroke-width:0.505292" x="48.089367" y="45.416836">D</tspan></text>
      <text xml:space="preserve" style="font-weight:bold;font-stretch:condensed;font-size:8.87389px;font-family:Arial;-inkscape-font-specification:'Arial, Bold Condensed';fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.505292;stroke-opacity:1" x="54.558205" y="48.250385" id="text16-9"><tspan sodipodi:role="line" id="tspan16-1" style="fill:#96ca4f;fill-opacity:1;stroke:none;stroke-width:0.505292" x="54.558205" y="48.250385">O</tspan></text>
      <g id="g1" transform="matrix(1.1426343,0,0,1.1426343,24.136464,-10.044912)" style="stroke-width:1.67137">
        <text xml:space="preserve" style="font-weight:bold;font-stretch:condensed;font-size:7.7611px;font-family:Arial;-inkscape-font-specification:'Arial, Bold Condensed';fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:0.442217;stroke-opacity:1" x="44.508698" y="51.014606" id="text16-5"><tspan sodipodi:role="line" id="tspan16-8" style="fill:#96ca4f;fill-opacity:1;stroke:none;stroke-width:0.442217" x="44.508698" y="51.014606">S</tspan></text>
      </g>
      <text xml:space="preserve" style="font-weight:bold;font-stretch:condensed;font-size:8.87389px;font-family:Arial;-inkscape-font-specification:'Arial, Bold Condensed';fill:#96ca4f;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.505292;stroke-opacity:1" x="65.022789" y="48.250385" id="text17"><tspan sodipodi:role="line" id="tspan17" style="stroke-width:0.505292" x="65.022789" y="48.250385">C</tspan></text>
    </g>
  </g>
</svg>
</a>

<ul class="px-4 my-10 ext-links">
  <li class="mt-1">
    <div class=" mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">Getting Started</span>
    </div>
    <ul class="menu-content ml-6 ">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/getting-started.html">Overview</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/Tutorials/">Tutorials</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/dockerfiles/">Setting up with Docker</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/buildsystem/repo-cheatsheet.html">Repo manifest cheat sheet</a>
        </li>
    </ul>
  </li>
  <li class="mt-1">
    <div class=" mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">The seL4 Kernel</span>
    </div>
    <ul class="menu-content ml-6 ">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4/">Overview</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/buildsystem/host-dependencies.html">Setting up</a>
        </li>
      <li class="pl-3 pb-1 border-l-1 bordercol">
        <div class="text-sm  menu-title text-light hover:text-hi">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron h-4 w-4 mb-0.5 -ml-2 -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
          <span class="cursor-pointer">Tutorial</span>
        </div>
        <ul class="menu-content ml-3 ">
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/setting-up.html">Setting up</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/get-the-tutorials.html">Getting the tutorials</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/hello-world.html">Hello world</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/capabilities.html">Capabilities</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/untyped.html">Untyped</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/mapping.html">Mapping</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/threads.html">Threads</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/ipc.html">IPC</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/notifications.html">Notifications</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/interrupts.html">Interrupts</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/fault-handlers.html">Fault handling</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/mcs.html">MCS</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/seL4-end.html">End</a>
            </li>
        </ul>
      </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/Tutorials/how-to-seL4.html">How-to</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4/api-doc.html">API docs</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4/manual.html">Manual</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/Hardware/">Supported platforms</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4/verified-configurations.html">Verified configurations</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4/configurations.html">Configurations</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/buildsystem/standalone.html">Standalone seL4 builds</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4/bfgen.html">Bitfield generator</a>
        </li>
      <li class="pl-3 pb-1 border-l-1 bordercol">
        <div class="text-sm  menu-title text-light hover:text-hi">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron h-4 w-4 mb-0.5 -ml-2 -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
          <span class="cursor-pointer">Testing &amp; benchmarking</span>
        </div>
        <ul class="menu-content ml-3 ">
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/sel4test/">seL4test</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/sel4-tutorials/debugging-guide.html">Debugging guide</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/sel4-tutorials/debugging-userspace.html">Debugging user space</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/sel4bench/">sel4bench</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/sel4-tutorials/benchmarking-guide.html">Benchmarking guide</a>
            </li>
        </ul>
      </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4/kernel-contribution.html">Contributing</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4/porting.html">Porting to a new platform</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/releases/seL4.html">Releases</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="https://github.com/seL4/seL4">Sources</a>
        </li>
    </ul>
  </li>
<li class="-mt-2">&nbsp;</li>
  <li class="mt-1">
    <div class=" mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">Microkit</span>
    </div>
    <ul class="menu-content ml-6 ">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/microkit/">Overview</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/microkit/setting-up.html">Setting up your machine</a>
        </li>
      <li class="pl-3 pb-1 border-l-1 bordercol">
        <div class="text-sm  menu-title text-light hover:text-hi">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron h-4 w-4 mb-0.5 -ml-2 -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
          <span class="cursor-pointer">Tutorial</span>
        </div>
        <ul class="menu-content ml-3 ">
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/microkit/tutorial/welcome.html">Welcome</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/microkit/tutorial/part0.html">Part 0 - Setting up</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/microkit/tutorial/part1.html">Part 1 - Serial server</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/microkit/tutorial/part2.html">Part 2 - Client</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/microkit/tutorial/part3.html">Part 3 - Wordle server</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/microkit/tutorial/part4.html">Part 4 - Virtual machines</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/microkit/tutorial/end.html">End</a>
            </li>
        </ul>
      </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/microkit/manual/latest/">Manual</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/microkit/roadmap.html">Roadmap</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/microkit/platforms.html">Supported platforms</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/releases/microkit.html">Releases</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="https://github.com/seL4/microkit">Sources</a>
        </li>
    </ul>
  </li>
  <li class="mt-1">
    <div class="font-bold mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer ">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">CAmkES</span>
    </div>
    <ul class="menu-content ml-6 on">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/camkes/">Overview</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/camkes/setting-up.html">Setting up your machine</a>
        </li>
      <li class="pl-3 pb-1 border-l-1 bordercol">
        <div class="text-sm  menu-title text-light hover:text-hi">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron h-4 w-4 mb-0.5 -ml-2 -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
          <span class="cursor-pointer">Tutorials</span>
        </div>
        <ul class="menu-content ml-3 ">
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/hello-camkes-0.html">Hello CAmkES</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/hello-camkes-1.html">Introduction</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/hello-camkes-2.html">Events</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/hello-camkes-timer.html">Timer</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/camkes-vm-linux.html">Virtual Machines</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/camkes-vm-crossvm.html">Cross-VM connectors</a>
            </li>
        </ul>
      </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/Tutorials/how-to-CAmkES.html">How-to</a>
        </li>
        <li class="text-hi border-f_green-500 pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/camkes/manual.html">Manual</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/camkes/hardware.html">Supported platforms</a>
        </li>
      <li class="pl-3 pb-1 border-l-1 bordercol">
        <div class="text-sm  menu-title text-light hover:text-hi">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron h-4 w-4 mb-0.5 -ml-2 -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
          <span class="cursor-pointer">Virtualisation</span>
        </div>
        <ul class="menu-content ml-3 ">
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/camkes-vm/">CAmkES VM</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/virtualization/docs/libsel4vm.html">VM library</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/projects/virtualization/docs/libsel4vmm.html">VMM library</a>
            </li>
        </ul>
      </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/releases/camkes.html">Releases</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="https://github.com/seL4/camkes-tool/">Sources</a>
        </li>
    </ul>
  </li>
<li class="-mt-2">&nbsp;</li>
  <li class="mt-1">
    <div class=" mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">C support</span>
    </div>
    <ul class="menu-content ml-6 ">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/sel4runtime/">C runtime</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/user_libs/">User-level libraries</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/buildsystem/">Build System</a>
        </li>
      <li class="pl-3 pb-1 border-l-1 bordercol">
        <div class="text-sm  menu-title text-light hover:text-hi">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron h-4 w-4 mb-0.5 -ml-2 -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
          <span class="cursor-pointer">Tutorials</span>
        </div>
        <ul class="menu-content ml-3 ">
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/libraries-1.html">Init & Threads</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/libraries-2.html">IPC</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/libraries-3.html">ELF loading & Processes</a>
            </li>
            <li class="text-light bordercol pl-3 border-l-1 text-sm leading-5 hover:text-hi">
              <a href="/Tutorials/libraries-4.html">Timer</a>
            </li>
        </ul>
      </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/Tutorials/how-to-libs.html">How-to</a>
        </li>
    </ul>
  </li>
  <li class="mt-1">
    <div class=" mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">Rust support</span>
    </div>
    <ul class="menu-content ml-6 ">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/rust/">Overview</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/rust/how-to-use.html">How to use</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/rust/tutorial/introduction.html">Tutorial</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="https://sel4.github.io/rust-sel4/">API</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/rust/supported-configurations.html">Supported configurations</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/rust/releases.html">Releases</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="https://github.com/seL4/rust-sel4">Sources</a>
        </li>
    </ul>
  </li>
<li class="-mt-2">&nbsp;</li>
  <li class="mt-1">
    <div class=" mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">ELF loader</span>
    </div>
    <ul class="menu-content ml-6 ">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/elfloader/">ELF loader for C</a>
        </li>
    </ul>
  </li>
  <li class="mt-1">
    <div class=" mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">capDL</span>
    </div>
    <ul class="menu-content ml-6 ">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/capdl/">Overview</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/capdl/lang-spec.html">Language Spec</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/projects/capdl/c-loader-app.html">capDL loader (C)</a>
        </li>
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/releases/capDL.html">Releases</a>
        </li>
    </ul>
  </li>
<li class="-mt-2">&nbsp;</li>
  <li class="mt-1">
    <div class=" mb-1 menu-title hover:text-hi leading-none">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" data-slot="icon" class="menu-chevron p-0 h-4 w-4 mb-px -mr-0.5 inline cursor-pointer rotate-270">
  <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/>
</svg>
      <span class="cursor-pointer text-sm">Examples &amp; demos</span>
    </div>
    <ul class="menu-content ml-6 ">
        <li class="text-light bordercol pb-1 pl-3 border-l-1 text-sm leading-5 hover:text-hi">
          <a href="/examples.html">Overview</a>
        </li>
    </ul>
  </li>
</ul>

      </div>
      <div id="sidebar-handle"
           class="flex-none relative cursor-col-resize min-h-full
                  bg-gray-200 dark:bg-gray-700 w-px">
      </div>
    </div>
    <div class="flex-1">
      
<div class="w-full pb-px bg-gray-200 dark:bg-gray-700">
  <header class="h-[2rem] sm:h-[2.5rem] lg:h-[3.5rem] w-full flex flex-row items-center gap-2 md:gap-4 md:py-2 std-bg">
    <div id="burger">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="text-dark ml-3 mr-0 sm:mr-3 lg:mx-4 w-4 h-4 lg:w-6 lg:h-6 cursor-pointer">
  <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"/>
</svg>
    </div>
    <div class="flex-1"></div>
    <a href="/releases.html"
      class="text-lighter hover:text-light hover:underline text-tiny sm:text-xs lg:text-sm font-semibold">
      Releases
    </a>
    <a href="https://sel4.systems/Contribute/"
      class="text-lighter hover:text-light hover:underline text-tiny sm:text-xs lg:text-sm font-semibold">
      Contribute
    </a>
    <a href="https://sel4.systems/contact.html"
      class="text-lighter hover:text-light hover:underline text-tiny sm:text-xs lg:text-sm font-semibold">
      Contact
    </a>
    <a href="https://sel4.systems/support.html"
      class="text-lighter hover:text-light hover:underline text-tiny sm:text-xs lg:text-sm font-semibold">
      Support
    </a>
    <!-- main site button -->
    <a href="https://sel4.systems"
      class="flex-none button-outline ml-0 text-tiny px-2 py-0.5 sm:px-3 sm:py-1 h-4 sm:h-6 md:py-2 md:h-8 lg:h-9 md:text-xs lg:text-sm mr-0 md:mr-4">Main Site
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" aria-hidden="true" viewBox="0 0 24 24" stroke="currentColor" data-slot="icon" class="hidden sm:inline-icon">
<path stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" d="M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"/>
</svg>
    </a>
    <!-- github button -->
    <a href="https://github.com/seL4"
      class="mr-2 lg:mr-6 px-0 sm:px-3 pt-2 sm:pt-1 pb-2 block text-gray-400 dark:text-gray-500 hover:text-gray-500 dark:hover:text-gray-300">
      <span class="sr-only">seL4 on GitHub</span>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4 sm:w-5 sm:h-5 lg:w-6 lg:h-6">
<path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
</svg>
    </a>
  </header>
</div>

      <div class="grid grid-cols-1  h-[calc(100%-3rem)]">
        <div class="flex flex-col max-w-full overflow-y-auto">
          <div id="main-div" class="flex-1 max-w-full mr-0 sm:mr-8 xl:mr-64 ">
            <main class="mx-6 md:mx-10 xl:mx-12 my-12
                        overflow-x-auto" id="page-top">

              <div class="theprose mx-auto  ext-links">
  <h1 id="camkes-manual">CAmkES Manual</h1>

<!--
     Copyright 2017, Data61, CSIRO (ABN 41 687 119 230)

     SPDX-License-Identifier: CC-BY-SA-4.0
-->

<p>This document describes the structure and functionality of CAmkES, a platform
for building componentised systems for embedded platforms. The documentation is
broken into sections for users, template authors and developers. The
<a href="#usage">Usage</a> section is for people wanting to develop systems
using CAmkES as a platform. The <a href="#templating">Templating</a> section is
for people wanting to write their own CAmkES templates and use more complex
functionality. Finally the <a href="#developers">Developers</a> section is for
people wanting to modify the internals of CAmkES itself. If you are modifying
the internals of CAmkES, it is recommended that you read the entirety of this
documentation. Regardless of which section is most relevant for you, you should
at least familiarise yourself with the <a href="#terminology">Terminology</a> section.</p>

<p>CAmkES’ primary target platform is the
<a href="http://sel4.systems/">seL4 microkernel</a>. The seL4 kernel and its functionality
are not discussed in this document. It is assumed that the reader has read the
seL4 programming references and is familiar with how this kernel operates and
the mechanisms it provides.</p>

<h2 id="terminology">Terminology</h2>

<p>Throughout this document some domain specific terminology is used that may have
connotations outside CAmkES/component systems. To avoid confusion the meanings
of these terms are made explicit below.</p>

<p><strong>Abstract Syntax Tree (AST)</strong></p>

<blockquote>
  <p>An internal representation of the results of parsing a generalised grammar.
  More thorough definitions of ASTs are provided
  <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">elsewhere</a>, but this is
  noted here because the abbreviation ‘AST’ is used heavily in this
  documentation.</p>
</blockquote>

<p><strong>Architecture Description Language (ADL)</strong></p>

<blockquote>
  <p>The CAmkES syntax for describing a component system. Most component platforms
  have their own architecture description language for describing a set of
  components and how they are wired together, but the term ‘ADL’ will be used
  in this documentation to exclusively refer to the CAmkES input specification
  language.</p>
</blockquote>

<p><strong>Assembly</strong></p>

<blockquote>
  <p>A top-level element that encapsulates a component system description. An
  assembly can be thought of as a complete description of a full system.
  A system must contain at least one assembly. A system with more than one
  assembly is equivalent to a system with one assembly whose composition
  and configuration sections are the concatenation of the composition and
  configuration sections of each assembly.</p>
</blockquote>

<p><strong>Attribute</strong></p>

<blockquote>
  <p>Components and connectors can have extra data of an arbitrary type associated
  with them. These are referred to as attributes. The description of a
  component/connector must describe the name of the attribute and its type. The
  value of the attribute itself is unspecified. It is assigned when the entity
  is instantiated, and this assignment is referred to as a <em>setting</em>. Attributes
  are generally used to specialise or differentiate a component at runtime.
  The types of attributes can be constructed as a collection or <em>struct</em> of
  any of the basic CAmkES types: int, unsigned int, char, unsigned char, string.
  It is possible to give an attribute a default value when it is declared.  If
  there are no settings for an attribute, the default setting will be used.  If
  an attribute is aliased to a different attribute that also has a default,
  then the different attribute’s default will override the original default.</p>
</blockquote>

<p id="component"><strong>Component</strong></p>

<blockquote>
  <p>A <em>type</em> of functional entity. It is important to stress this distinction.
  ‘Component’ is used colloquially to refer to both types and instances, but in
  a formal sense ‘component’ refers only to the type. To make this more
  concrete, the statement <code class="language-plaintext highlighter-rouge">component foo f</code> describes a component <em>instance</em> f,
  whose <em>type</em> is foo.</p>
</blockquote>

<p><strong>Composition</strong></p>

<blockquote>
  <p>A container for the component and connector instantiations that form a system.
  This is essentially a syntactic element for delimiting sections in a
  specification. It is contained by an assembly block, along with an optional
  configuration.</p>
</blockquote>

<p><strong>Compound Component</strong></p>

<blockquote>
  <p>A component with a composition section, and optionally a configuration section.</p>
</blockquote>

<p><strong>Configuration</strong></p>

<blockquote>
  <p>A container for describing settings. This is a syntactic element to hold the
  assignment of attributes for a given system. It is expressed inside an
  assembly block.</p>
</blockquote>

<p id="connection"><strong>Connection</strong></p>

<blockquote>
  <p>An instantiation of a connector. Connections connect two <em>instances</em>. Because
  the instantiation of a connector does not really specialise the connector in
  any particular way, it is easy to conflate the two. However, the sources make
  important distinctions between connectors and connections.</p>
</blockquote>

<p><strong>Connector</strong></p>

<blockquote>
  <p>A <em>type</em> of link between instances. The distinction between ‘connector’ and
  ‘connection’ is the same as that between ‘component’ and ‘instance,’ i.e. a
  connection is an instantiation of a particular connector.</p>
</blockquote>

<p><strong>Consumes</strong></p>

<blockquote>
  <p>Event interfaces that are accepted by a component. If a component consumes a
  particular event it means that it is expecting to receive and handle that
  event.</p>
</blockquote>

<p><strong>Dataport</strong></p>

<blockquote>
  <p>Port interfaces that are used by a component. A component’s dataports
  are expected to be available to it at runtime as shared memory regions.</p>
</blockquote>

<p><strong>Direction</strong></p>

<blockquote>
  <p>The flow of a parameter of a procedure method. The only possible directions
  are ‘in’ (caller to callee), ‘out’ (callee to caller), ‘inout’
  (bidirectional) and ‘refin’ (identical to ‘in’ except for the C backend where
  this is optimised to pass-by-reference).</p>
</blockquote>

<p><strong>Emits</strong></p>

<blockquote>
  <p>Event interfaces that are expressed by a component. If a component emits a
  given event it means that it produces events of this type.</p>
</blockquote>

<p><strong>Event</strong></p>

<blockquote>
  <p>An asynchronous signal interface of a component. Events are defined completely
  by their identifier, a numerical value. It may be helpful to think of this
  value as mapping to something like an interrupt number or a signal type,
  although they do not necessarily represent hardware messages.</p>
</blockquote>

<p><strong>Exported Interface</strong></p>

<blockquote>
  <p>An interface of an internal instance that is presented under the name of an
  identically typed interface in its containing component. The purpose of
  exported interfaces is to expose a coherent outward-facing set of interfaces
  from a component, while potentially implementing those interfaces within
  nested components.</p>
</blockquote>

<p><strong>Instance</strong></p>

<blockquote>
  <p>An instantiation of a component type. Of course ‘instance’ can be used to
  refer to an instantiation of any type, but when you see the term ‘instance’ in
  the sources it is generally referring to the instantiation of a component. To
  give a concrete example, in the statement <code class="language-plaintext highlighter-rouge">component foo f</code> f is an instance.</p>
</blockquote>

<p><strong>Interface</strong></p>

<blockquote>
  <p>An abstract exposed interaction point of a component. There could be a
  distinction made here between type and instance of one of these interaction
  points, but in practice this is not necessary and ambiguity rarely arises. The
  subcategories of interface are <em>procedure</em>, <em>event</em> and <em>port</em>.</p>
</blockquote>

<p><strong>Internal Instance</strong></p>

<blockquote>
  <p>A component instance declared inside a compound component’s composition section.</p>
</blockquote>

<p><strong>Internal Connection</strong></p>

<blockquote>
  <p>A connection declared inside a compound component which connects two internal
  instance interfaces. That is, any connection declared inside a compound
  component.</p>
</blockquote>

<p><strong>Maybe</strong></p>

<blockquote>
  <p>Interfaces of components can be made optional using the <code class="language-plaintext highlighter-rouge">maybe</code> keyword. Optional
  interfaces do not need to be connected to any other interfaces. C symbols associated
  with optional interfaces (functions and dataport pointers) are declared as weak
  symbols. If nothing is connected to an optional interface, its associated symbols
  lack definitions. That is, functions and dataport pointers associated with unconnected
  optional interfaces take the value <code class="language-plaintext highlighter-rouge">NULL</code> at runtime.</p>
</blockquote>

<p><strong>Method</strong></p>

<blockquote>
  <p>An item of a procedure. When targeting a conventional programming language,
  methods usually map directly to generated functions.</p>
</blockquote>

<p><strong>Parameter</strong></p>

<blockquote>
  <p>A piece of data referenced by a procedure method. This can be thought of as an
  argument to a function.</p>
</blockquote>

<p><strong>Port</strong></p>

<blockquote>
  <p>The interface type that represents shared memory semantics.</p>
</blockquote>

<p id="procedure"><strong>Procedure</strong></p>

<blockquote>
  <p>An interface with function call semantics. Procedures consist of a series of
  methods that can be invoked independently.</p>
</blockquote>

<p><strong>Provides</strong></p>

<blockquote>
  <p>Procedure interfaces implemented by a component. When targeting a conventional
  programming language this typically means that the component contains
  functions that are implementations of each method in the procedures provided.</p>
</blockquote>

<p><strong>Setting</strong></p>

<blockquote>
  <p>An assignment of an attribute to a specific value. A setting does not specify
  the type of the attribute, because this has already been described by the
  attribute as specified in the component/connector description.</p>
</blockquote>

<p><strong>Struct</strong></p>

<blockquote>
  <p>A collection of named attribute fields that can be used as an attribute type
  for a component <em>attribute</em>.</p>
</blockquote>

<p><strong>Type</strong></p>

<blockquote>
  <p>A procedure method’s return type or parameter type. This information does not
  include the direction of a parameter. An example type is something like
  ‘string.’</p>
</blockquote>

<p><strong>Uses</strong></p>

<blockquote>
  <p>Procedure interfaces that are invoked by a component. When targeting a
  conventional programming language this typically means that the component
  contains calls to functions that are expected to implement each method in the
  procedures used.</p>
</blockquote>

<p><strong>Virtual Interface</strong></p>

<blockquote>
  <p>An interface of a compound component that is not implemented by that
  component, but is an alias for internal instance’s interface.</p>
</blockquote>

<p>A concrete example:</p>

<pre><code class="language-camkes">struct cat {
    int paws;
    string name;
}

procedure thing {
  int func(in int x);
}

component foo {
  control;
  uses thing t1;
  emits sig s1;
  dataport buffer b1;
  attribute cat kitty;
}

component bar {
  provides thing t2;
  consumes sig s2;
  dataport buffer b2;
}

assembly {
  composition {
    component foo f;
    component bar b;

    connection RPC c1(from f.t1, to b.t2);
    connection Notification c2(from f.s1, to b.s2);
    connection SharedData c3(from f.b1, to b.b2);
  }
  configuration {
      f.kitty = {"name": "meows", "paws": 4};
  }
}
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">thing</code> is a <strong>procedure</strong></li>
  <li><code class="language-plaintext highlighter-rouge">int</code> is a <strong>type</strong></li>
  <li><code class="language-plaintext highlighter-rouge">func</code> is a <strong>method</strong></li>
  <li><code class="language-plaintext highlighter-rouge">in</code> is a <strong>direction</strong></li>
  <li><code class="language-plaintext highlighter-rouge">x</code> is a <strong>parameter</strong></li>
  <li><code class="language-plaintext highlighter-rouge">sig</code> is an <strong>event</strong></li>
  <li><code class="language-plaintext highlighter-rouge">buffer</code> is a <strong>port</strong></li>
  <li><code class="language-plaintext highlighter-rouge">foo</code> and <code class="language-plaintext highlighter-rouge">bar</code> are <strong>component</strong>s</li>
  <li><code class="language-plaintext highlighter-rouge">t1</code> is a <strong>uses</strong></li>
  <li><code class="language-plaintext highlighter-rouge">s1</code> is a <strong>emits</strong></li>
  <li><code class="language-plaintext highlighter-rouge">b1</code> and <code class="language-plaintext highlighter-rouge">b2</code> are <strong>dataport</strong>s</li>
  <li><code class="language-plaintext highlighter-rouge">t2</code> is a <strong>provides</strong></li>
  <li><code class="language-plaintext highlighter-rouge">s2</code> is a <strong>consumes</strong></li>
  <li><code class="language-plaintext highlighter-rouge">assembly { ... }</code> is an <strong>assembly</strong></li>
  <li><code class="language-plaintext highlighter-rouge">composition { ... }</code> is a <strong>composition</strong></li>
  <li><code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">b</code> are <strong>instance</strong>s</li>
  <li><code class="language-plaintext highlighter-rouge">RPC</code>, <code class="language-plaintext highlighter-rouge">Notification</code> and <code class="language-plaintext highlighter-rouge">SharedData</code> are <strong>connector</strong>s</li>
  <li><code class="language-plaintext highlighter-rouge">c1</code>, <code class="language-plaintext highlighter-rouge">c2</code> and <code class="language-plaintext highlighter-rouge">c3</code> are <strong>connection</strong>s</li>
  <li><code class="language-plaintext highlighter-rouge">cat</code> is a <strong>struct</strong></li>
  <li><code class="language-plaintext highlighter-rouge">kitty</code> is an <strong>attribute</strong></li>
  <li><code class="language-plaintext highlighter-rouge">f.kitty</code> is a <strong>setting</strong></li>
</ul>

<h2 id="usage">Usage</h2>

<p>This section is targeted at people building systems on top of the CAmkES
platform. It assumes a basic knowledge of C programming.</p>

<h3 id="dependencies">Dependencies</h3>

<p>Please see <a href="/projects/buildsystem/host-dependencies.html">the
docsite</a>
for information about dependencies.</p>

<p>To check you have the appropriate dependencies installed:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./tools/check_deps.py
</code></pre></div></div>

<h3 id="tutorial">Tutorial</h3>

<p>This section is aimed at getting you up and running with CAmkES applications
and increase your familiarity with the CAmkES environment. We assume you are
working in the CAmkES project repository for this.</p>

<h4 id="running-a-simple-example">Running a Simple Example</h4>

<p>There’s an example application under apps/simple that involves two components,
echo and client, communicating over a single interface.</p>

<p><img src="imgs/echo.svg" alt="Simple system" /></p>

<p>To build this example, from the top-level directory run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>build
<span class="nb">cd </span>build
../init-build.sh <span class="nt">-DPLATFORM</span><span class="o">=</span>sabre <span class="nt">-DCAMKES_APP</span><span class="o">=</span>simple <span class="nt">-DSIMULATION</span><span class="o">=</span>1
ninja
</code></pre></div></div>

<p>This produces an image images/capdl-loader-image-arm-imx6. To run this image in
qemu:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./simulate
</code></pre></div></div>

<p>You should see debugging output from the system initialisation, followed by:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo_int: 42 -&gt; 42
echo_float: 273421.437500 -&gt; 273421.437500
echo_double: 273421.427400 -&gt; 273421.427400
echo_mix: 273421.427400 -&gt; 273421
echo_string: "hello world" -&gt; "hello world"
echo_parameter: 123 -&gt; 123 (returned = 123)
increment_parameter: 100 -&gt; 101
After the client
</code></pre></div></div>

<p>To understand what this example is doing, open the files
apps/simple/components/Echo/src/echo.c and
apps/simple/components/Client/src/client.c. The implementations of the echo
functions are in echo.c and they are called from client.c. The function call
itself happens over a seL4 endpoint. The connection between the two components
is described in apps/simple/simple.camkes, and the functional interface that
echo is providing is described in apps/simple/interfaces/Simple.idl4.</p>

<p>If you want to run this example on IA32, repeat the above procedure with a new build
directory, replacing the configuration line with the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>../init-build.sh <span class="nt">-DPLATFORM</span><span class="o">=</span>ia32 <span class="nt">-DCAMKES_APP</span><span class="o">=</span>simple <span class="nt">-DSIMULATION</span><span class="o">=</span>1
</code></pre></div></div>

<h4 id="creating-an-application">Creating An Application</h4>

<p>Let’s create some simple hello world applications using the different interface
types available in CAmkES. Create a new application directory with two component
types:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> apps/helloworld/components/Hello
<span class="nb">mkdir</span> <span class="nt">-p</span> apps/helloworld/components/Client
</code></pre></div></div>

<p>Functional interfaces, referred to as procedures, are made up of a set of
methods. Define an interface that the components will communicate over and save
this under apps/helloworld/interfaces/MyInterface.idl4:</p>

<pre><code class="language-camkes">/* apps/helloworld/interfaces/MyInterface.idl4 */

procedure MyInterface {
  void print(in string message);
}
</code></pre>

<p>This interface consists of a single method, print that takes an input parameter
of type string. Note that, although we are planning to implement this component
in C, interfaces are defined with abstract types that have equivalents in all
target languages. In the case of C, string maps to <code class="language-plaintext highlighter-rouge">char*</code>. Each component
needs a description of the interfaces it exposes or needs in so-called
Architecture Description Language. Create these in
apps/helloworld/components/Hello/Hello.camkes and
apps/helloworld/components/Client/Client.camkes.</p>

<pre><code class="language-camkes">/* apps/helloworld/components/Hello/Hello.camkes */

import "../../interfaces/MyInterface.idl4";

component Hello {
  provides MyInterface inf;
}

/* apps/helloworld/components/Client/Client.camkes */

import "../../interfaces/MyInterface.idl4";

component Client {
  control;
  uses MyInterface iface;
}
</code></pre>

<p>Note that each component description needs to import the interface file we
created above from apps/helloworld/interfaces. Import statements function
similar to C’s <code class="language-plaintext highlighter-rouge">#include</code>, in that they can be enclosed in double quotes and
are relative to the source file, or enclosed in angle brackets and refer to a
built-in file. The Hello component is to contain an implementation of
MyInterface and the Client component will expect to be provided with an
implementation of MyInterface. The <code class="language-plaintext highlighter-rouge">control</code> keyword indicates that Client is
what is called an active component. This means it will contain a main function
(prototyped as <code class="language-plaintext highlighter-rouge">run</code>) and have an active thread of control.</p>

<p>Create a file to describe the instantiation and structure of the system at
apps/helloworld/helloworld.camkes.</p>

<pre><code class="language-camkes">/* apps/helloworld/helloworld.camkes */

import &lt;std_connector.camkes&gt;;
import "components/Hello/Hello.camkes";
import "components/Client/Client.camkes";

assembly {
  composition {
    component Hello h;
    component Client c;
    connection seL4RPCCall conn(from c.iface, to h.inf);
  }
}
</code></pre>

<p>This file begins with several import statements that reference other files.
Hello.camkes and Client.camkes are the files we created above, while
std_connector.camkes is a built-in file that defines the standard CAmkES
connector types. The body of the system description instantiates each component
once, <code class="language-plaintext highlighter-rouge">h</code> of type <code class="language-plaintext highlighter-rouge">Hello</code> and <code class="language-plaintext highlighter-rouge">c</code> of type <code class="language-plaintext highlighter-rouge">Client</code>. The components’ interfaces
are connected via a connection, <code class="language-plaintext highlighter-rouge">conn</code>, of type <code class="language-plaintext highlighter-rouge">seL4RPCCall</code>.</p>

<p>Now for the implementation of the components. Create a single source file for
Hello as apps/helloworld/components/Hello/src/hello.c:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* apps/helloworld/components/Hello/src/hello.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;camkes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">inf__init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">inf_print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Client says: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The header camkes.h is generated by the CAmkES build system and contains
prototypes for functions related to MyInterface that this component needs to
implement. Note that the actual implementations of interface functions are
prefixed with the component-local name of the interface (inf from Hello.camkes
above) and an underscore. The function <code class="language-plaintext highlighter-rouge">inf__init</code> is for this component to do
any required initialisation. In the case of this example we have no
initialisation to perform.</p>

<p>Create a source file for Client as
apps/helloworld/components/Client/src/client.c that calls these functions as if
they are directly available to it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* apps/helloworld/components/Client/src/client.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;camkes.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>
  <span class="n">iface_print</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The entry point of a CAmkES component is <code class="language-plaintext highlighter-rouge">run</code>.</p>

<p>The final thing is to add some build system boiler plate to be able to build
the system.
Copy one of the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> files from another application or create
<code class="language-plaintext highlighter-rouge">apps/helloworld/CMakeLists.txt</code> from scratch:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.7.2)

project(helloworld C)

DeclareCAmkESComponent(Client SOURCES components/Client/src/client.c)
DeclareCAmkESComponent(Hello SOURCES components/Hello/src/hello.c)

DeclareCAmkESRootserver(helloworld.camkes)
</code></pre></div></div>

<p>You’re now ready to compile and run this application, by entering the <code class="language-plaintext highlighter-rouge">CAMKES_APP</code> value in the cmake configuration GUI:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>build
cmake <span class="nb">.</span> <span class="nt">-DCAMKES_APP</span><span class="o">=</span>helloworld <span class="c"># set `helloworld` as CAMKES_APP</span>
ninja
./simulate
</code></pre></div></div>

<p>If all goes well you should see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Client says: hello world
</code></pre></div></div>

<p>Congratulations, you’ve just made your first CAmkES application.</p>

<h4 id="under-the-hood">Under the Hood</h4>

<p>We basically just wrote a verbose and roundabout Hello World example, so what
benefit is CAmkES providing here? Note how the function call between the two
components looks just like a normal function invocation in C, even though the
two components are actually in different address spaces. During compilation
so-called glue code is generated to connect the two components via a seL4
endpoint and transparently pass the function invocation and return over this
channel. The communication itself is abstracted in the ADL description in
apps/helloworld/helloworld.camkes. The connection type we used was seL4RPCCall, but
it is possible to use another connection type here without modifying the code of
the components themselves.</p>

<p>CAmkES provides some interface types for other modes of interaction than
function calls. Events can be used for asynchronous communication and dataports
for shared memory.</p>

<h4 id="an-example-of-events">An Example of Events</h4>

<p>Events are the CAmkES interface type for modelling asynchronous communication
between components. Like procedures, events connect a single component to
another single component, but the receiver of an event (called consumer in
CAmkES parlance) has several ways of receiving the event. The following walks
through an example demonstrating these.</p>

<p>Create a new application directory with two components:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> apps/helloevent/components/Emitter
<span class="nb">mkdir</span> <span class="nt">-p</span> apps/helloevent/components/Consumer
</code></pre></div></div>

<p>Events, unlike procedures, do not need to be defined in a separate IDL file. You
can simply refer to the event type in your component ADL files and CAmkES will
infer an event type. Create the following description for Emitter:</p>

<pre><code class="language-camkes">/* apps/helloevent/components/Emitter/Emitter.camkes */

component Emitter {
  control;
  emits MyEvent e;
}
</code></pre>

<p>This description says Emitter is an active component (the control keyword) and
it emits a single event called e of type MyEvent. Create some basic source code
for the component that does nothing except emit the event itself:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* apps/helloevent/components/Emitter/src/main.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;camkes.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e_emit</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>CAmkES provides an emit function to send the event.</p>

<p>Now let’s create a description of the Consumer that will handle this event:</p>

<pre><code class="language-camkes">/* apps/helloevent/components/Consumer/Consumer.camkes */

component Consumer {
  control;
  consumes MyEvent s;
}
</code></pre>

<p>Note that this component consumes (handles) an event of the same type. Let’s
instantiate and connect these components together using another ADL file:</p>

<pre><code class="language-camkes">/* apps/helloevent/helloevent.camkes */

import &lt;std_connector.camkes&gt;;
import "components/Emitter/Emitter.camkes";
import "components/Consumer/Consumer.camkes";

assembly {
  composition {
    component Emitter source;
    component Consumer sink;
    connection seL4Notification channel(from source.e, to sink.s);
  }
}
</code></pre>

<p>In this file, seL4Notification is a seL4 specific connector for transmitting
asynchronous signals. The two instantiated components, source and sink are
connected over the connection channel.</p>

<p>As mentioned above, there are several ways for a component to receive an event.
The consumer can register a callback function to be invoked when the event is
received, they can call a blocking function that will return when the event is
received or they can call a polling function that returns whether an event has
arrived or not. Let’s add some source code that uses all three:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;camkes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">fired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Callback fired!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fired</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">s_reg_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Registering callback...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">s_reg_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Polling...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">s_poll</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"We found an event!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"We didn't find an event</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Waiting...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">s_wait</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Unblocked by an event!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that we re-register the callback during the first execution of the handler.
Callbacks are deregistered when invoked, so if you want the callback to fire
again when another event arrives you need to explicitly re-register it.</p>

<p>We now have everything we need to run this system.</p>

<p>Create the appropriate <code class="language-plaintext highlighter-rouge">apps/helloevent/CMakeLists.txt</code> as for the previous example. Compile the system and
run it with the simulate script as per the previous example. If all goes well you
should see something like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Registering callback...
Callback fired!
Polling...
We didn't find an event
Waiting...
Unblocked by an event!
Callback fired!
</code></pre></div></div>

<p>Whether you find an event during polling will be a matter of the schedule that
seL4 uses to run the components. This covers all the functionality available
when using events. One final point that may not be obvious from the example is
that callbacks will always be fired in preference to polling/waiting. That is,
if a component registers a callback and then waits on an event to arrive, the
callback will be fired when the first instance of the event arrives and the wait
will return when/if the second instance of the event arrives.</p>

<h4 id="an-example-of-dataports">An Example of Dataports</h4>

<p>Dataports are CAmkES’ abstraction of shared memory. All
components participating in a connection involving dataports get read/write
access to the dataport by default. The default dataport type is
<code class="language-plaintext highlighter-rouge">Buf</code>, which is implemented as a byte array in C of size <code class="language-plaintext highlighter-rouge">PAGE_SIZE</code>.
Alternatively you can specify a user-defined type for the shared memory region.
This example will demonstrate both.</p>

<p>Create two components that will use a pair of dataports for communication:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> apps/hellodataport/components/Ping
<span class="nb">mkdir</span> <span class="nt">-p</span> apps/hellodataport/components/Pong
</code></pre></div></div>

<p>Let’s define a struct that will be used as one of the dataports:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* apps/hellodataport/include/porttype.h */</span>

<span class="cp">#ifndef _PORTTYPE_H_
#define _PORTTYPE_H_
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">MyData</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="n">bool</span> <span class="n">ready</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MyData_t</span><span class="p">;</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>Now let’s create an ADL description of the Ping component:</p>

<pre><code class="language-camkes">/* apps/hellodataport/components/Ping/Ping.camkes */

component Ping {
  include "porttype.h";
  control;
  dataport Buf d1;
  dataport MyData_t d2;
}
</code></pre>

<p>Note that we need to include the C header in the ADL. CAmkES does not actually
parse this header, but it needs to know to <code class="language-plaintext highlighter-rouge">#include</code> it whenever it references
the <code class="language-plaintext highlighter-rouge">MyData_t</code> type. Add a similar description for Pong:</p>

<pre><code class="language-camkes">/* apps/hellodataport/components/Pong/Pong.camkes */

component Pong {
  include "porttype.h";
  control;
  dataport Buf s1;
  dataport MyData_t s2;
}
</code></pre>

<p>Now we’ll create some basic code for each component to use the dataports:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* apps/components/Ping/src/main.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;camkes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;porttype.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// index in d1 to use to signal pong</span>
<span class="cp">#define D1_READY_IDX 20
</span>
<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">hello</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Ping: sending %s...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hello</span><span class="p">);</span>
  <span class="n">strncpy</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">d1</span><span class="p">,</span> <span class="n">hello</span><span class="p">,</span> <span class="n">D1_READY_IDX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">d1_release</span><span class="p">();</span> <span class="c1">// ensure the assignment below occurs after the strcpy above</span>
  <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">d1</span><span class="p">)[</span><span class="n">D1_READY_IDX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="cm">/* Wait for Pong to reply. We can assume d2_data is
   * zeroed on startup by seL4.
   */</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">d2</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d2_acquire</span><span class="p">();</span> <span class="c1">// ensure d2 is read from in each iteration</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Ping: received %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">d2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* apps/components/Pong/src/main.c */</span>

<span class="cp">#include</span> <span class="cpf">&lt;camkes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;porttype.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="c1">// index in s1 to use to signal ping</span>
<span class="cp">#define S1_READY_IDX 20
</span>
<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">world</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span>

  <span class="cm">/* Wait for Ping to message us. We can assume s1_data is
   * zeroed on startup by seL4.
   */</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">s1</span><span class="p">)[</span><span class="n">S1_READY_IDX</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">s1_acquire</span><span class="p">();</span> <span class="c1">// ensure s1 is read from in each iteration</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Pong: received %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">s1</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Pong: sending %s...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">s2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>

  <span class="n">s2_release</span><span class="p">();</span> <span class="c1">// ensure the assignment below occurs after the strcpy above</span>
  <span class="n">s2</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note the use of <code class="language-plaintext highlighter-rouge">*_acquire()</code> and <code class="language-plaintext highlighter-rouge">*_release()</code> functions. These are used to maintain
coherency of shared memory between components. Call <code class="language-plaintext highlighter-rouge">*_acquire()</code> between multiple
reads from a dataport, where the correct behaviour of the program depends on the
contents of the dataport possibly changing between reads. Call <code class="language-plaintext highlighter-rouge">*_release()</code> between
multiple writes to a dataport, where the correct behaviour of the program depends
on writes preceding the <code class="language-plaintext highlighter-rouge">*_release()</code> in the program code being performed strictly
before the writes following it.</p>

<p>Typically, a real system would have a more complete communication protocol between
the two components, but for the purposes of this example spinning until a byte
changes is good enough. We’re ready to connect all these sources together with a
top-level ADL file:</p>

<pre><code class="language-camkes">/* apps/hellodataport/hellodataport.camkes */

import &lt;std_connector.camkes&gt;;
import "components/Ping/Ping.camkes";
import "components/Pong/Pong.camkes";

assembly {
  composition {
    component Ping ping;
    component Pong pong;

    connection seL4SharedData channel1(from ping.d1, to pong.s1);
    connection seL4SharedData channel2(from ping.d2, to pong.s2);
  }
}
</code></pre>

<p>Add the now familiar <code class="language-plaintext highlighter-rouge">apps/hellodataport/CMakeLists.txt</code>:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.7.2<span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>hellodataport C<span class="p">)</span>

<span class="c1"># Interface library for our dataport</span>
<span class="nb">add_library</span><span class="p">(</span>MyData INTERFACE<span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span>MyData INTERFACE <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_CURRENT_LIST_DIR</span><span class="si">}</span><span class="s2">/include"</span><span class="p">)</span>

<span class="nf">DeclareCAmkESComponent</span><span class="p">(</span>Ping SOURCES components/Ping/src/main.c LIBS MyData<span class="p">)</span>
<span class="nf">DeclareCAmkESComponent</span><span class="p">(</span>Pong SOURCES components/Pong/src/main.c LIBS MyData<span class="p">)</span>

<span class="nf">DeclareCAmkESRootserver</span><span class="p">(</span>hellodataport.camkes<span class="p">)</span>

</code></pre></div></div>
<p>We added an interface library containing the shared header file. The LIBS field in DeclareCAmkESComponent can be
used to specify any argument that can be ordinarily given to CMake’s <code class="language-plaintext highlighter-rouge">target_link_libraries()</code>.</p>

<p>If you now compile and run the resulting
image you should see some output like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ping: sending hello...
Pong: received hello
Pong: sending world...
Ping: received world.
</code></pre></div></div>
<h4 id="an-example-of-structs-and-arrays-for-collections">An example of structs and arrays for collections</h4>

<p>A struct can be defined with the <code class="language-plaintext highlighter-rouge">struct</code> keyword.  The attributes that make
up the struct are listed in a <code class="language-plaintext highlighter-rouge">type</code> <code class="language-plaintext highlighter-rouge">name</code> format (similar to C).</p>

<p>Arrays are specified by appending the attribute name with a <code class="language-plaintext highlighter-rouge">[]</code>.  The size of
an array is set at code generation time when the setting for the attribute is
specified.</p>

<p>This is an example of a valid camkes specification.  The corresponding C file
is shown after.  To find a size of an attribute array, the sizeof macro can be
used as shown in the example.</p>

<pre><code class="language-camkes">struct client_config {
    string name;
    int age;
    int height;
}
struct cat {
    int b[];
    int c;
}

component Client {
    control;
    attribute client_config config;
    attribute cat array_in_struct;
}

assembly {
    composition {
        component Client client;
    }

    configuration {
        client.config = {"name": "Zed","age": 39, "height": 34+4};
        client.array_in_struct = {"b": [3,4,5,6], "c": 4};
    }
}

</code></pre>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;camkes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"struct: %s: height plus age is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="n">age</span> <span class="o">+</span> <span class="n">config</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"array_in_struct: array length: %d, first element %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array_in_struct</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array_in_struct</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">array_in_struct</span><span class="p">.</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="tutorial-summary">Tutorial Summary</h4>

<p>You should now have a reasonably comprehensive understanding of the basic
connector functionality available in CAmkES. The other apps in the CAmkES
project repository provide some more diverse system examples.</p>

<h3 id="overview">Overview</h3>

<p>The various parts that comprise CAmkES can be used in several ways, including
executing a standalone tool as an end user or importing a Python module to
perform programmatic operations. These two uses are broken up into the sections
below. <a href="#command-line-arguments">Command Line Arguments</a> describes how to invoke
standalone CAmkES functionality, and <a href="#modules">Modules</a> describes how to import
and use the various functional units. Importing CAmkES functionality as a module
is strictly more powerful than running the command line tool, but usage
is more complicated. Note that these sections only describe external
interaction with these artefacts. If you are interested in the internals of
these you will need to refer to the <a href="#developers">Developers</a> section.</p>

<h3 id="command-line-arguments">Command Line Arguments</h3>

<p>This section discusses the standalone tool that is part of the CAmkES
ecosystem. This can be run from the command line with a shell script wrapper
that checks its dependencies:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>camkes.sh args...
</code></pre></div></div>

<p>The following command line arguments are available.</p>

<p><strong>–cache</strong>, <strong>-c</strong>
<strong>–cache-dir</strong></p>

<blockquote>
  <p>In a complicated system, the compilation itself can be quite time intensive.
  CAmkES implements a template cache that reduces recompilation time within and
  across builds. The –cache option enables it.</p>
</blockquote>

<p><strong>–cpp</strong>
<strong>–nocpp</strong></p>

<blockquote>
  <p>Whether or not to run the C pre-processor over the ADL input specification
  before processing it. The ADL input specification, strictly, is not C source
  code, but sometimes it can be useful to have the ability to pre-process it as
  if it was. The CAmkES ADL grammar is sufficiently similar to C that you are
  unlikely to run into any problems in this respect.</p>
</blockquote>

<p><strong>-D</strong>, <strong>–debug</strong>
<strong>-q</strong>, <strong>–quiet</strong>
<strong>-v</strong>, <strong>–verbose</strong></p>

<blockquote>
  <p>Set the level of information and error reporting emitted. The last one of
  these options encountered on the command line takes precedence. Note that
  there is no option to set the default verbosity (which is more than –quiet,
  but less than –verbose). The verbosity setting is applied globally during
  execution. For example, applying –debug to inspect a parsing problem in the
  runner will also generate debugging output from the lexing phase.</p>
</blockquote>

<p><strong>–default-priority</strong></p>

<blockquote>
  <p>Threads in a seL4 system are all configured with an initial priority. This
  can be tuned via attributes, but otherwise threads inherit a global default.
  This parameter allows you to set the global default.</p>
</blockquote>

<p><strong>–default-affinity</strong></p>

<blockquote>
  <p>Threads and sched-contexts in a seL4 system are all configured with an initial
  affinity. This can be tuned via attributes, but otherwise threads inherit a
  global default, which is CPU index 0.</p>
</blockquote>

<p><strong>–elf</strong>, <strong>-E</strong></p>

<blockquote>
  <p>Pass an ELF file that is to contribute to the final CapDL specification of a
  system. This parameter allows you to pass in the compiled ELF binary of one of
  your component instances. The CAmkES build system should take care of passing
  this option.</p>
</blockquote>

<p><strong>-f FILE</strong>, <strong>–file FILE</strong></p>

<blockquote>
  <p>This argument sets FILE as the input to parse. This argument is required and
  only a single input file is supported.</p>
</blockquote>

<p><strong>-h</strong>, <strong>–help</strong></p>

<blockquote>
  <p>Shows usage information and then exits.</p>
</blockquote>

<p><strong>-I PATH</strong>, <strong>–import-path</strong></p>

<blockquote>
  <p>CAmkES specifications can contain <code class="language-plaintext highlighter-rouge">import</code> statements that are either
  relative or builtin. Analogously to C pre-processor <code class="language-plaintext highlighter-rouge">#include</code> directives,
  builtin <code class="language-plaintext highlighter-rouge">import</code> statements use angle brackets, <code class="language-plaintext highlighter-rouge">import &amp;lt;foo.camkes&amp;gt;</code>.
  This option is similar to the C compiler flag, -I, and adds a directory to be
  searched for these builtin files. When resolving imports, directories will be
  searched in the order in which they are specified on the command line with
  the first match taking preference. Note, <em>unlike</em> the C pre-processor this
  option <em>only</em> affects searches for builtin imports. Relative imports are
  <em>always</em> relative to the location they are included from.</p>
</blockquote>

<p><strong>–item</strong>, <strong>-T</strong></p>

<blockquote>
  <p>Specify the output you wish the runner to generate. The available options
  here are dependent on your input specification and it is best to look at
  examples to see what is expected following this option.</p>
</blockquote>

<p><strong>–largeframe</strong></p>

<blockquote>
  <p>Back large virtual address space regions with large frames when possible. On
  ARM and IA32 platforms, multiple frame sizes are supported for mapping
  physical memory into address spaces. It is more efficient to use a single
  large frame to cover a region than many small frames. This flag controls
  whether this promotion to large frames happens automatically. Note that this
  does not affect DMA pools, for which mappings are controlled by the
  –largeframe-dma option below.</p>
</blockquote>

<p><strong>–largeframe-dma</strong></p>

<blockquote>
  <p>Back components’ DMA pools with large frames when possible. This works
  entirely independently to the –largeframe option. The reason for this
  separation is that large frame promotion of a DMA pool on ARM can be a
  little complicated to achieve. For more information, see
  <a href="#efficient-dma">Efficient DMA</a>.</p>
</blockquote>

<p><strong>–platform</strong>, <strong>-p</strong></p>

<blockquote>
  <p>The target output platform. This determines some aspects of the environment
  that the template being rendered is expected to function in. This option is
  only relevant to the runner. Valid platforms are “architecture-semantics”,
  “autocorres”, “CIMP”, “GraphViz” and “seL4”. The “GraphViz” option is for
  producing visual representations of a system and the “seL4” option is for
  producing binaries. All other platforms are verification frameworks.</p>
</blockquote>

<p><strong>–templates</strong>, <strong>-t</strong></p>

<blockquote>
  <p>You can use this option to add an extra directory to search for templates
  before the built-in location. This can allow you to extend the available
  templates or even override the built-in templates.</p>
</blockquote>

<p><strong>–version</strong></p>

<blockquote>
  <p>Print basic version information and then exit.</p>
</blockquote>

<p>The following options are all related to runtime optimisations within the
templates. Note that most of these are highly seL4 specific and would make no
sense in the context of another platform.</p>

<p><strong>–frpc-lock-elision</strong>
<strong>–fno-rpc-lock-elision</strong></p>

<blockquote>
  <p>Locks are used within the seL4RPC connector templates to prevent threads
  interfering with each other’s execution. When this option is enabled, CAmkES
  will determine when this lock is not required and remove it at compile-time.</p>
</blockquote>

<p><strong>–fcall-leave-reply-cap</strong>
<strong>–fno-call-leave-reply-cap</strong></p>

<blockquote>
  <p>The seL4RPCCall connector needs to save a so-called reply cap on the
  receiver’s side to prevent accidental deletion in the presence of
  interference from other interfaces. In certain circumstances there is
  actually no risk of the reply cap being deleted. With this option enabled,
  CAmkES will detect these scenarios and operate on the reply cap in place to
  avoid extra syscalls.</p>
</blockquote>

<p>The following options are all related to verification of templates outputs.</p>

<p><strong>–fprovide-tcb-caps</strong>
<strong>–fno-provide-tcb-caps</strong></p>

<blockquote>
  <p>By default each thread gets a cap to its own TCB. The only purpose of this is
  to allow it to suspend itself when it exits. These TCBs can complicate
  reasoning about a generated CapDL specification. This option elides these TCB
  caps at the cost of threads messily VM faulting when they exit.</p>
</blockquote>

<h3 id="modules">Modules</h3>

<p>Each subset of CAmkES functionality is encapsulated in a Python module that
defines exactly what functions and variables are exported. The APIs of these
are described below and usage should be reasonably straightforward. To import
any of these modules the top-level directory of this distribution should be in
your <code class="language-plaintext highlighter-rouge">PYTHONPATH</code> environment variable. The available modules are:</p>

<p><strong><a href="#camkesast">camkes.ast</a></strong></p>

<blockquote>
  <p>Definitions of objects that can appear in the result of parsing a CAmkES
  specification. If you want to reference the types of objects in a resulting
  AST you will need to import this.</p>
</blockquote>

<p><strong>camkes.internal</strong></p>

<blockquote>
  <p>Functionality used by other CAmkES modules. You should not import this
  module.</p>
</blockquote>

<p><strong><a href="#camkesparser">camkes.parser</a></strong></p>

<blockquote>
  <p>To parse an input specification in memory or to do post-processing
  manipulations on a specification-derived AST you will need to import this
  module. The runner imports this module to perform its job.</p>
</blockquote>

<p><strong>camkes.runner</strong></p>

<blockquote>
  <p>This module is available, but does not export any symbols. You should never
  need to import it.</p>
</blockquote>

<p><strong><a href="#camkestemplates">camkes.templates</a></strong></p>

<blockquote>
  <p>If you need to lookup builtin templates you will need to import this module.
  Note that this module does not contain any template <em>instantiation</em> logic.</p>
</blockquote>

<h4 id="camkesast">camkes.ast</h4>

<p>The result of parsing a CAmkES specification is an Abstract Syntax Tree (AST),
representing the input as a set of interconnected nodes. When using the default
parser, the object returned is of type, <code class="language-plaintext highlighter-rouge">LiftedAST</code>, which is defined in this
module. <code class="language-plaintext highlighter-rouge">LiftedAST</code> and its children all inherit from a base type, <code class="language-plaintext highlighter-rouge">ASTObject</code>,
that provides common functionality like traversal and comparison.</p>

<p>One of the AST objects is a class, <code class="language-plaintext highlighter-rouge">Reference</code>. Objects of this class are used
in the AST to represent symbols that refer to entities that are defined
elsewhere. During parsing, references are removed from the AST as they are
resolved to the entities to which they refer. In particular, if you are using
the default parser, the returned AST will never contain any <code class="language-plaintext highlighter-rouge">Reference</code>
objects.</p>

<p>In the code and in this document there is some discussion of ‘collapsing’ AST
references. This is meant to refer to replacing the <code class="language-plaintext highlighter-rouge">Reference</code> object in the
AST by the entity to which it refers. Note that this needs to be done by
reference so that you still only end up with a single copy of the entity, but
multiple pointers to it.</p>

<p>If you are not using the default CAmkES parser, but are assembling your own
from the <a href="#camkesparser">parser module</a>, it is important to note that objects
of the classes in the AST module are only created in the stage 3 parser. If you
are inspecting the output of any low-level parser prior to stage 3, you will
not see objects from camkes.ast.</p>

<h4 id="camkesparser">camkes.parser</h4>

<p>If you need to manipulate the AST, rather than just simply printing it
out, you will want to import the parser as a module into your own code. After
importing this module, you can interact with the parser through the following
high-level API.</p>

<p><strong><code class="language-plaintext highlighter-rouge">parse_file(filename, options=None)</code></strong></p>

<blockquote>
  <p>Parse a file into a <code class="language-plaintext highlighter-rouge">LiftedAST</code>. The <code class="language-plaintext highlighter-rouge">options</code> arguments is expected to be a
  namespace as constructed by the runner. If you have non-standard parsing
  requirements, you may find this function is insufficiently flexible for your
  needs. In this case, you will need to compose the low-level parsers. You can
  see a rough guide of how to do this in camkes/parser/parser.py.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">parse_string(string, options=None)</code></strong></p>

<blockquote>
  <p>Parse a string into a <code class="language-plaintext highlighter-rouge">LiftedAST</code>. This function works identically to the
  previous in all respects, except obviously you will not have accurate
  filename information.</p>
</blockquote>

<h4 id="camkestemplates">camkes.templates</h4>

<p>This module contains functionality for looking up builtin templates. The
templates themselves are actually stored in this directory (camkes/templates)
as well to reduce confusion. The description below only describes the externally
facing behaviour of this module. If you need to understand how template lookups
actually work you will need to read the source code and comments.</p>

<p>The API only contains a single class through which all access is intended to
flow.</p>

<p><code class="language-plaintext highlighter-rouge">Templates.</code><strong><code class="language-plaintext highlighter-rouge">__init__(self, platform)</code></strong></p>

<blockquote>
  <p>Create a new template store in which templates can later be looked up. The
  category of templates that are available from this store is specialised via
  <strong><code class="language-plaintext highlighter-rouge">platform</code></strong>. At time of writing the valid values of <strong><code class="language-plaintext highlighter-rouge">platform</code></strong> are
  ‘seL4’, ‘CIMP’ and ‘GraphViz’.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Templates.</code><strong><code class="language-plaintext highlighter-rouge">add_root(self, root)</code></strong></p>

<blockquote>
  <p>Add a directory to be searched for templates when performing lookups. This
  directory is added <em>before</em> existing directories, which allows you to
  overwrite builtin templates if you wish.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Templates.</code><strong><code class="language-plaintext highlighter-rouge">get_roots(self)</code></strong></p>

<blockquote>
  <p>Return the list of directories that are searched for templates. Note that if
  you are the only client operating on this <code class="language-plaintext highlighter-rouge">Templates</code> object you will know
  the contents of this list anyway, but this function is provided for
  convenience.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Templates.</code><strong><code class="language-plaintext highlighter-rouge">add(self, connector_name, path, template)</code></strong></p>

<blockquote>
  <p>Add a template to the lookup dictionary, such that it can later be returned
  in a template lookup. Only connector templates can be added currently (i.e.
  component templates and top-level templates cannot be added). The caller
  provides the <strong><code class="language-plaintext highlighter-rouge">connector_name</code></strong> this template applies to (e.g.
  ‘seL4MyConnector’), a partial lookup <strong><code class="language-plaintext highlighter-rouge">path</code></strong> to the template (e.g.
  ‘from.source’) and a roots-relative path to the <strong><code class="language-plaintext highlighter-rouge">template</code></strong> itself. Again,
  this function is sufficiently complicated that it may be easier to comprehend
  its usage from reading <code class="language-plaintext highlighter-rouge">camkes/runner/__main__.py</code>.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Templates.</code><strong><code class="language-plaintext highlighter-rouge">lookup(self, path, entity=None)</code></strong></p>

<blockquote>
  <p>Locate and return a template. The <strong><code class="language-plaintext highlighter-rouge">path</code></strong> provided should be a full lookup
  path from the second-level of the lookup dictionary (i.e. not including the
  platform prefix). For example, a valid <strong><code class="language-plaintext highlighter-rouge">path</code></strong> might be
  ‘seL4RPCCall.from.source’. If you provide an <strong><code class="language-plaintext highlighter-rouge">entity</code></strong> this is used as a guard
  on the lookup. The guards come into play when looking up connector templates.
  In this situation the connector type of the connection you pass in as
  <strong><code class="language-plaintext highlighter-rouge">entity</code></strong> will be used to determine if a given template matches your
  lookup. This function returns <code class="language-plaintext highlighter-rouge">None</code> if a matching template can’t be found.</p>
</blockquote>

<h3 id="runtime-api">Runtime API</h3>

<p>This section describes the environment in which you, as a user, will find
yourself writing code. Standard C library functionality is available, but as a
CAmkES application, there is also extra functionality provided by generated
code and supporting libraries. This extra functionality is what is documented
in this section.</p>

<p>Parts of the functionality discussed below are provided by the library,
libsel4camkes. In a typical seL4 project the user would need to specify that
they want to link against this library. This is not required in CAmkES as it is
assumed you always want to link against this library. For more information from
a CAmkES developer’s point of view, see <a href="#core-libraries">Core Libraries</a>. The
API is bidirectional in a sense, in that some of the functions below are called
by CAmkES code and expected to be provided by the user. This is noted in their
descriptions.</p>

<p>The following types are available at runtime from the C context of a component:</p>

<p><strong><code class="language-plaintext highlighter-rouge">Buf</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/dataport.h&gt;</code>)</p>

<blockquote>
  <p>The underlying type of a dataport. A user is never expected to instantiate
  one of these manually, but they are free to do so if they wish.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">camkes_error_handler_t</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/error.h&gt;</code>)</p>
<blockquote>
  <p>The type of an error handler for dealing with errors originating in glue
  code. For more information about this see
  <a href="#error-handling">Error Handling</a>.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">camkes_tls_t</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/tls.h&gt;</code>)</p>

<blockquote>
  <p>Thread-local storage metadata. This captures some necessary information for
  constructing a thread context inside templates. A user is never expected to
  instantiate or deal with one of these, but they are free to do so if they
  wish.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">dataport_ptr_t</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/dataport.h&gt;</code>)</p>

<blockquote>
  <p>A component-independent representation of a pointer into a dataport. This is
  intended to be an opaque type to the user that is only ever used via the
  <code class="language-plaintext highlighter-rouge">dataport_wrap_ptr</code> and <code class="language-plaintext highlighter-rouge">dataport_unwrap_ptr</code> functions.</p>
</blockquote>

<p>The following variables are available:</p>

<p><strong><em><code class="language-plaintext highlighter-rouge">dataport</code></em></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes.h&gt;</code>)</p>

<blockquote>
  <p>If a component has a dataport they will be provided with a symbol of the
  dataport’s name that is a pointer of the type they specified in their CAmkES
  specification. As mentioned previously, the default type is <code class="language-plaintext highlighter-rouge">Buf</code>.</p>
</blockquote>

<p>The following functions are available at runtime:</p>

<p><strong><code class="language-plaintext highlighter-rouge">camkes_error_handler_t camkes_register_error_handler(camkes_error_handler_t handler)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/error.h&gt;</code>)
<strong><code class="language-plaintext highlighter-rouge">camkes_error_handler_t </code> <em><code class="language-plaintext highlighter-rouge">interface</code></em><code class="language-plaintext highlighter-rouge">_register_error_handler(camkes_error_handler_t handler)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/error.h&gt;</code>)</p>

<blockquote>
  <p>Register a component-wide or interface-specific error handler, respectively.
  These functions return the previous error handler or <code class="language-plaintext highlighter-rouge">NULL</code> if there was no
  previously installed error handler. For more information see
  <a href="#error-handling">Error Handling</a>.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">dataport_ptr_t dataport_wrap_ptr(void *ptr)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/dataport.h&gt;</code>)
<strong><code class="language-plaintext highlighter-rouge">void *dataport_unwrap_ptr(dataport_ptr_t ptr)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/dataport.h&gt;</code>)</p>

<blockquote>
  <p>Utility functions for creating and destroying a component-independent
  representation of a pointer into a dataport. This <code class="language-plaintext highlighter-rouge">dataport_ptr_t</code> can be
  passed over a procedure interface to be unwrapped by the receiving component.
  Unwrapping will fail if the underlying pointer is not into a dataport that is
  shared with the receiver. <code class="language-plaintext highlighter-rouge">dataport_unwrap_ptr</code> returns <code class="language-plaintext highlighter-rouge">NULL</code> on failure.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void</code> <em><code class="language-plaintext highlighter-rouge">dataport</code></em><code class="language-plaintext highlighter-rouge">_acquire(void)</code></strong></p>

<blockquote>
  <p>An acquire memory fence. Any read from the dataport preceding this fence in
  program order will take place before any read or write following this fence in
  program order. In uniprocessor environments, this is always a compiler memory
  fence. In multiprocessor environments, memory barrier instructions will be
  emitted if necessary, depending on the affinities of component instances
  connected by the dataport.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void</code> <em><code class="language-plaintext highlighter-rouge">dataport</code></em><code class="language-plaintext highlighter-rouge">_release(void)</code></strong></p>

<blockquote>
  <p>A release memory fence. Any write to the dataport following this fence in
  program order will take place after any read or write preceding this fence in
  program order. In uniprocessor environments, this is always a compiler memory
  fence. In multiprocessor environments, memory barrier instructions will be
  emitted if necessary, depending on the affinities of component instances
  connected by the dataport.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">size_t</code> <em><code class="language-plaintext highlighter-rouge">dataport</code></em><code class="language-plaintext highlighter-rouge">_get_size(void)</code></strong></p>

<blockquote>
  <p>Returns the size for the specific dataport this function gets called for. In
  addition to this function, every component that has a dataport will be
  provided with a macro <em><code class="language-plaintext highlighter-rouge">dataport</code></em><code class="language-plaintext highlighter-rouge">_size</code> that is defined to the size of the
  invdividual dataport. This macro allows declaring fixed size arrays, as the
  <code class="language-plaintext highlighter-rouge">C</code> language requires a constant-expression for this.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void *camkes_dma_alloc(size_t size, int align)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/dma.h&gt;</code>)
<strong><code class="language-plaintext highlighter-rouge">void camkes_dma_free(void *ptr, size_t size)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/dma.h&gt;</code>)</p>

<blockquote>
  <p>Allocator for DMA device operations. These are closely linked with the DMA
  pool functionality, as the allocation is backed by this pool.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">uintptr_t camkes_dma_get_paddr(void *ptr)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/dma.h&gt;</code>)</p>

<blockquote>
  <p>Translate a pointer into a DMA region into a physical address. This function
  assumes that the pointer you are passing in is to a byte within a region
  allocated to you by <code class="language-plaintext highlighter-rouge">camkes_dma_alloc_page</code>. The reason for needing to obtain
  the physical address of a pointer is typically to pass to a device that is
  going to access this region outside of the scope of the MMU. For more
  information, see the <a href="#direct-memory-access">DMA</a> section below.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void *camkes_io_map(void *cookie, uintptr_t paddr, size_t size, int cached, ps_mem_flags_t flags)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/io.h&gt;</code>)</p>

<blockquote>
  <p>Lookup the translation to virtual address from the physical address of a
  memory-mapped IO device. This function is primarily to ease interaction with
  libplatsupport infrastructure, so refer to its documentation where
  appropriate.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int camkes_io_mapper(ps_io_mapper_t *mapper)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/io.h&gt;</code>)</p>

<blockquote>
  <p>Construct an IO mapping structure to pass to libplatsupport. See source
  comments for more information about how to use this.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int camkes_io_ops(ps_io_ops_t *ops)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/io.h&gt;</code>)</p>

<blockquote>
  <p>Construct an IO operations structure to pass to libplatsupport. See source
  comments for more information about how to use this.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int camkes_io_port_in(void *cookie, uint32_t port, int io_size, uint32_t *result)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/io.h&gt;</code>)
<strong><code class="language-plaintext highlighter-rouge">int camkes_io_port_out(void *cookie, uint32_t port, int io_size, uint32_t val)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/io.h&gt;</code>)</p>

<blockquote>
  <p>Read from or write to a hardware IO port. This function is primarily to ease
  interaction with libplatsupport infrastructure, so refer to its documentation
  where appropriate.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int camkes_io_port_ops(ps_io_port_ops_t *ops)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/io.h&gt;</code>)</p>

<blockquote>
  <p>Construct an IO port access structure to pass to libplatsupport. See source
  comments for more information about how to use this.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">const char *get_instance_name(void)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes.h&gt;</code>)</p>

<blockquote>
  <p>Returns the name of this component instance. This can be helpful if you want
  to write component functionality that has different behaviour depending on
  which instance it is.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int</code> <em><code class="language-plaintext highlighter-rouge">instance</code></em><code class="language-plaintext highlighter-rouge">_main(int thread_id)</code></strong></p>

<blockquote>
  <p>A component instance’s entry point. This is generated by the platform and
  invokes the user’s <code class="language-plaintext highlighter-rouge">run</code> function when complete.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int main(int thread_id)</code></strong> (in libsel4camkes.a)</p>

<blockquote>
  <p>This function — the C entry point to a component — is provided by
  the platform. Components should not provide their own <code class="language-plaintext highlighter-rouge">main</code>.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int run(void)</code></strong></p>

<blockquote>
  <p>This function is expected to be provided by the user in a control component.
  It is invoked by <code class="language-plaintext highlighter-rouge">main</code> after component initialisation is complete.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">NORETURN _start(int thread_id)</code></strong> (in libsel4camkes.a)</p>

<blockquote>
  <p>This function provides the assembly entry point of a component and consists
  of a brief trampoline to <code class="language-plaintext highlighter-rouge">main</code>. The user can override this if they wish, but
  it is unwise to do this unless you have a deep understanding of the runtime
  environment.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void pre_init(void)</code></strong></p>

<blockquote>
  <p>This function can be optionally provided by the user. If it is present, it
  will be invoked <em>before</em> the component’s interfaces’ init functions have
  executed. Be aware that you will not have full runtime support in this
  function. For example, interfaces cannot be expected to be accessible.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void</code> <em><code class="language-plaintext highlighter-rouge">interface</code></em><code class="language-plaintext highlighter-rouge">__init(void)</code></strong></p>

<blockquote>
  <p>For each incoming or outgoing interface a user can optionally provide this
  function. If it is present it will be invoked <em>after</em> the component’s
  pre-init function, but <em>before</em> its post-init function. The same caveats about
  the runtime environment from above are applicable here.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void post_init(void)</code></strong></p>

<blockquote>
  <p>This function can be optionally provided by the user. If it is present, it
  will be invoked <em>after</em> the component’s pre-init function and after all
  interfaces’ init functions, but <em>before</em> any interface enters its run
  function.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int</code> <em><code class="language-plaintext highlighter-rouge">interface</code></em><code class="language-plaintext highlighter-rouge">__run(void)</code></strong></p>

<blockquote>
  <p>This function can be provided for any incoming or outgoing interface. If it
  is present, it will be invoked after all pre- and post-init functions have
  run.</p>
</blockquote>

<p><strong><em><code class="language-plaintext highlighter-rouge">return</code></em> <em><code class="language-plaintext highlighter-rouge">procedure</code></em><code class="language-plaintext highlighter-rouge">_</code><em><code class="language-plaintext highlighter-rouge">method</code></em><code class="language-plaintext highlighter-rouge">(</code><em><code class="language-plaintext highlighter-rouge">args...</code></em><code class="language-plaintext highlighter-rouge">)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes.h&gt;</code>)</p>

<blockquote>
  <p>In a component that provides a procedure interface, things are somewhat
  reversed and the implementation calls functions that you are expected to
  provide. For each method in the procedure you are expected to provide a
  matching implementation. In a component that uses a procedure interface,
  functions of this form are available for you to call.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void</code> <em><code class="language-plaintext highlighter-rouge">event</code></em><code class="language-plaintext highlighter-rouge">_emit(void)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes.h&gt;</code>)</p>

<blockquote>
  <p>In a component that emits an event a function prefixed with the event’s name
  is available that causes the event to be sent.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void</code> <em><code class="language-plaintext highlighter-rouge">event</code></em><code class="language-plaintext highlighter-rouge">_poll(void)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes.h&gt;</code>)</p>

<blockquote>
  <p>In a component that consumes an event a function prefixed with the event’s
  name is available that returns whether there is a pending event. Note, this
  function never blocks.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">int</code> <em><code class="language-plaintext highlighter-rouge">event</code></em><code class="language-plaintext highlighter-rouge">_reg_callback(void (*callback)(void*), void *arg)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes.h&gt;</code>)</p>

<blockquote>
  <p>In a component that consumes an event a function prefixed with the event’s
  name is available for registering a callback for this event. When the event
  is received, the provided function will be invoked with the argument provided
  when registering the callback. Note that registered
  callbacks take precedence over threads blocked on calls to <em><code class="language-plaintext highlighter-rouge">event</code></em><code class="language-plaintext highlighter-rouge">_wait</code>.
  <em><code class="language-plaintext highlighter-rouge">event</code></em><code class="language-plaintext highlighter-rouge">_reg_callback</code> returns 0 on success and non-zero if the callback
  could not be registered.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void</code> <em><code class="language-plaintext highlighter-rouge">event</code></em><code class="language-plaintext highlighter-rouge">_wait(void)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes.h&gt;</code>)</p>

<blockquote>
  <p>In a component that consumes an event a function prefixed with the event’s
  name is available that blocks until the event is received.</p>
</blockquote>

<h3 id="synchronization-primitives">Synchronization Primitives</h3>

<p>CAmkES provides three primitives for intra-component mutual exclusion and synchronization.
Mutexes, semaphores, and binary semaphores are declared similarly to properties of a component definition:</p>

<pre><code class="language-camkes">component Foo {
  has mutex m;
  has semaphore s;
  has binary_semaphore b;
}
</code></pre>

<p>By default semaphores have a count (initial value) of 1, and binary semaphores have an initial value
of 0. This can be adjusted using an attribute:</p>

<pre><code class="language-camkes">assembly {
  composition {
    component Foo f;
    ...
  }
  configuration {
    f.s_value = 4;
    f.b_value = 1; // must be either 0 or 1
    ...
  }
}
</code></pre>

<p>An application can lock or unlock a declared mutex and call post or wait on a
declared semaphore or binary semaphore. For example, for the above declarations, the following
functions are available at runtime:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Lock mutex m */</span>
<span class="kt">int</span> <span class="nf">m_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Unlock mutex m */</span>
<span class="kt">int</span> <span class="nf">m_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Wait on semaphore s */</span>
<span class="kt">int</span> <span class="nf">s_wait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Try to wait on semaphore s */</span>
<span class="kt">int</span> <span class="nf">s_trywait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Post to semaphore s */</span>
<span class="kt">int</span> <span class="nf">s_post</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Wait on a binary semaphore b */</span>
<span class="kt">int</span> <span class="nf">b_wait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Post to a binary semaphore b */</span>
<span class="kt">int</span> <span class="nf">b_post</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div></div>

<p>The CAmkES mutexes and semaphores have the behaviour you would expect from an
seL4 or pthreads implementation.</p>

<p>There is no native support for inter-component locks. However, it is possible
to construct these on top of the CAmkES platform. An example of how you would
do this is shown in the lockserver example application in the CAmkES project
repository.</p>

<h3 id="direct-memory-access">Direct Memory Access</h3>

<p>Direct Memory Access (DMA) is a hardware feature that allows devices to read
and write memory without going via the CPU. It is intended to give a fast I/O
path to devices, for which memory access is usually the bottleneck.</p>

<p>This only has specific relevance in the context of CAmkES because on platforms
without an <a href="https://en.wikipedia.org/wiki/IOMMU">IOMMU</a> devices perform DMA
accesses on physical memory, rather than virtual memory. The implications of
this are that, when a device is being directed to perform I/O by a driver, it
needs to know the physical address(es) of the memory it is about to access. On
seL4 reversing a virtual memory mapping requires specific capability operations
and thus CAmkES needs to be aware of any memory region which you intend to use
for DMA transfers.</p>

<p>To allocate some memory for DMA within a specific component instance you
describe a DMA pool with a size in bytes. For example,</p>

<pre><code class="language-camkes">assembly {
  composition {
    component Foo f;
    ...
  }
  configuration {
    f.dma_pool = 8192;
  }
}
</code></pre>

<p>This declares an 8KB pool of memory that is available for DMA operations.
Within the component you must allocate and release pointers into this region
with the <code class="language-plaintext highlighter-rouge">camkes_dma_alloc</code> and <code class="language-plaintext highlighter-rouge">camkes_dma_free</code> functions described above.
The allocation function accepts a size and alignment constraint, but be aware
that allocation may not be efficient or guaranteed when requesting more than
4Kb. Note that if you declare a DMA pool that is not page-aligned (4K on the
platforms we support) it will automatically be rounded up.</p>

<h4 id="efficient-dma">Efficient DMA</h4>

<p>For components that need to perform large DMA operations, you will need to
allocate a large DMA pool. Backing the virtual address space mappings for such
a pool with 4KB frames can lead to performance issues. For this reason, you may
wish to use the command line option –largeframe-dma to back DMA pools with
large frames.</p>

<p>This is relatively straightforward on IA32, but on an ARM platform you may run
into a limitation of the GNU Assembler that prevents the large alignments
required by the DMA pool. Support for working around this is provided by the
CAmkES build system, but is a little complicated, so the precise steps for
achieving this in a CAmkES project are documented below.</p>

<p>Enable large frame promotion for the DMA pool in your build configuration:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake <span class="nb">.</span> <span class="nt">-DCAmkESDMALargeFramePromotion</span><span class="o">=</span>ON
</code></pre></div></div>

<p>On older versions of binutils, if you were using a large enough DMA pool
to get promoted to large frames with an alignment constraint that was rejected
by the GNU Assembler, you should see output like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/tmp/ccfGhK5Z.s: Assembler messages:
/tmp/ccfGhK5Z.s:1483: Error: alignment too large: 15 assumed
</code></pre></div></div>
<p>Updating binutils should fix this issue.</p>

<h3 id="error-handling">Error Handling</h3>

<p>Some runtime conditions can lead to an error in the glue code. For example, if
an interface accepts a string parameter and the caller passes a string that is
too large to fit in the IPC buffer. Errors can also arise in glue code if your
user code is not well-behaved and attempts to operate directly on capabilities.
The glue code attempts to handle all errors occurring from user mistakes and
malicious user code, to the best of its abilities. It also attempts to handle
errors that occur as a result of unexpected runtime conditions. For example,
accesses to a device that unexpectedly is not found at runtime.</p>

<p>The mode of error handling can be configured at compile-time, but the default
mode is generally the only relevant one you will need. It allows for runtime
handling of errors. By default, all errors cause a diagnostic message and a
system halt on a debug kernel. To alter this behaviour, user code can call the
function <code class="language-plaintext highlighter-rouge">camkes_register_error_handler</code> (described in
<a href="#runtime-api">Runtime API</a>) and provide their own error handling function.
The user’s error handling will thenceforth be invoked by glue code whenever an
error is detected. The error handling function should return one of the
following values, documented further in <code class="language-plaintext highlighter-rouge">camkes/error.h</code>, that indicate to the
glue code how it should proceed:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CEA_DISCARD</code> — Ignore whatever message or request was currently being
handled and return to the original calling function of the user or an event
loop as appropriate. This is typically the failure mode you want for servers
that are intended to be robust against denial-of-service attacks from
malicious clients.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CEA_IGNORE</code> — Pretend the error was not detected and continue executing.
This is almost never the response you want to take, but it can be useful for
debugging or masking spurious errors.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CEA_ABORT</code> — Terminate the current thread with failure status. This is a
fail-stop response, though note it will not halt the rest of the system. If
the glue code is currently handling a request on behalf of a client, the
client will likely end up stuck blocked waiting for a response.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CEA_HALT</code> — Halt the entire system. This is only possible on a debug
kernel. On a release kernel it will act identically to <code class="language-plaintext highlighter-rouge">CEA_ABORT</code>.</p>
  </li>
</ul>

<p>To conditionally determine which response to return, the error handler is
passed a structure that describes the error that was detected. For details on
this structure, refer to <code class="language-plaintext highlighter-rouge">camkes/error.h</code>.</p>

<p>The mechanism just described allows for handling errors at a component-wide
level. In a more complicated component, there are often notional subsystems
that want to be able to handle their own errors independently. For this there
are interface-specific error handlers. Each interface has its own error handler
registration function as <em><code class="language-plaintext highlighter-rouge">interface</code></em><code class="language-plaintext highlighter-rouge">_register_error_handler</code>. Any interface that
does not have a registered interface-specific error handler will default to the
component-wide error handler.</p>

<h3 id="custom-attributes">Custom Attributes</h3>

<p>CAmkES allows the programmer to define arbitrary attributes of components.</p>

<pre><code class="language-camkes">component Foo {
  attribute string a;
  attribute int b;
}
</code></pre>

<p>These attributes are set in the configuration section of the assembly:</p>

<pre><code class="language-camkes">assembly {
  composition {
    component Foo f;
    ...
  }
  configuration {
    f.a = "Hello, World!";
    f.b = 42;
    ...
  }
}
</code></pre>

<p>This results in the specified values being available as global variables
in the glue code with the same name as the attribute.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"Hello, World!"</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="attributes-conversion-to-literal">Attribute’s conversion to literal</h4>

<p>Unfortunately, the <code class="language-plaintext highlighter-rouge">C</code> language (in contrast to C++) does not support using
<code class="language-plaintext highlighter-rouge">lvalues</code> as literals (e.g. when declaring an array), even if declared as const,
so we need to introduce a “mechanism” for converting CAmkES attributes to
literals.</p>

<p>The <code class="language-plaintext highlighter-rouge">CAMKES_CONST_ATTR</code> macro has been introduced for that purpose.</p>

<p>Actually, the macro does not really convert arbitrary variables, but rather
CAmkES declares a const variable and also adds a respective macro to the code,
which is then used for that purpose.</p>

<p>Usage example is presented below:</p>

<pre><code class="language-C">/* main.camkes */
assembly {
    composition {
        component FOO foo;
    }
    configuration {
        foo.lenData  = 16;
    }
}

/* Foo.c */
const int foo[CAMKES_CONST_ATTR(lenData)] = { 0 };

int run()
{
#if CAMKES_CONST_ATTR(lenData) &lt; 0xF0
    return 0;
#else
    return 1;
#endif
}
</code></pre>

<h3 id="hardware-components">Hardware Components</h3>

<p>A hardware component represents an interface to hardware in the form of a component.
Declaring a component with the <code class="language-plaintext highlighter-rouge">hardware</code> keyword creates a hardware component.</p>

<pre><code class="language-camkes">component Device {
  hardware;

  provides IOPort io_port;
  emits Interrupt irq;
  dataport Buf mem;
}
</code></pre>

<p>When an interface of a device component instance is connected to a regular
component, that component gets access to that device via some
hardware interface (interface here refers to a means of interacting with
hardware - not a CAmkES interface).
The type of hardware interface depends on the type of CAmkES interface,
and the connector used. Available connectors for hardware, and their
corresponding hardware interfaces are listed below.</p>

<p><strong>Interface:</strong> procedure            <br />
<strong>Keyword:</strong> <code class="language-plaintext highlighter-rouge">provides</code>               <br />
<strong>Connector:</strong> <code class="language-plaintext highlighter-rouge">seL4HardwareIOPort</code>   <br />
<strong>Description:</strong>
When using <code class="language-plaintext highlighter-rouge">IOPort</code> as the interface type, this provides access to IO ports. The connected
component gets access to the methods in the <code class="language-plaintext highlighter-rouge">IOPort</code> interface, which allow sending and receiving
data over IO ports. This is specific to the IA32 architecture.</p>

<p><strong>Interface:</strong> event                    <br />
<strong>Keyword:</strong> <code class="language-plaintext highlighter-rouge">emits</code>                      <br />
<strong>Connector:</strong> <code class="language-plaintext highlighter-rouge">seL4HardwareInterrupt</code>    <br />
<strong>Description:</strong>
An event is emitted when an interrupt occurs.</p>

<p><strong>Interface:</strong> port                 <br />
<strong>Keyword:</strong> <code class="language-plaintext highlighter-rouge">dataport</code>              <br />
<strong>Connector:</strong> <code class="language-plaintext highlighter-rouge">seL4HardwareMMIO</code>     <br />
<strong>Description:</strong>
Memory mapped registers can be accessed via the shared memory.</p>

<p>The following shows an example of connecting a hardware component to a driver
component. Note the order of arguments to the connection. <code class="language-plaintext highlighter-rouge">seL4HardwareInterrupt</code> requires
the hardware interface on the <code class="language-plaintext highlighter-rouge">from</code> side of the connection, whereas the other connectors
require the hardware interface on the <code class="language-plaintext highlighter-rouge">to</code> side.</p>

<pre><code class="language-camkes">component Driver {
  uses IOPort io_port;
  consumes Interrupt irq;
  dataport Buf mem;
}

assembly {
  composition {
    component Device dev;
    component Driver drv;
    ...
    connection seL4HardwareIOPort ioport_c(from drv.io_port, to dev.io_port);
    connection seL4HardwareInterrupt irq_c(from dev.irq, to drv.irq);
    connection seL4HardwareMMIO mmio_c(from drv.mem, to dev.mem);
  }
}
</code></pre>

<h4 id="configuration">Configuration</h4>

<p>Each type of hardware component interface has some configuration required for it
to work. This is done by setting attributes of instances of device components.</p>

<h5 id="mmio">MMIO</h5>

<p>The physical address of the memory, and size (in bytes) to make available
to a connected component must be specified. The example below specifies that
the port named <code class="language-plaintext highlighter-rouge">mem</code> of the component instance <code class="language-plaintext highlighter-rouge">d</code> is a 0x1000 byte region
starting at physical address 0xE0000000.</p>

<pre><code class="language-camkes">component Device {
  hardware;

  dataport Buf mem;
  ...
}

assembly {
  composition {
    component Device d;
    ...
  }
  configuration {
    d.mem_paddr = 0xE0000000;
    d.mem_size = 0x1000;
    ...
  }
}
</code></pre>

<h5 id="interrupts">Interrupts</h5>

<p>Depending on the platform different information needs to specified to
connect a hardware interrupt source with a components interrupt handler.</p>

<p>On ARM and if you are using the legacy x86 PIC controller then simply an
interrupt number must be specified. The example below specifies that
the event will be emitted when interrupt number 2 is received.</p>

<pre><code class="language-camkes">component Device {
  hardware;

  emits Interrupt irq;
  ...
}

assembly {
  composition {
    component Device d;
    ...
  }
  configuration {
    d.irq_irq_number = 2;
    ...
  }
}
</code></pre>

<p>If using the newer I/O APIC controller on x86 then you need to describe
the I/O APIC source and provide a destination vector. An I/O APIC source
is described in terms of</p>

<ul>
  <li>Physical I/O APIC controller indexed starting at 0. Typically a system
only has one of these</li>
  <li>Pin, ranging from 0 to 23, on the I/O APIC controller that the interrupt
will come in on</li>
  <li>The trigger mode and polarity of the interrupt</li>
</ul>

<p>The destination vector is a number in the range of 0 to 107 and must be unique
across all destination vectors defined in an assembly.</p>

<p>Selecting between edge and level trigger modes is done by setting the
<code class="language-plaintext highlighter-rouge">*_irq_ioapic_level</code> attribute where a value of <code class="language-plaintext highlighter-rouge">1</code> means level triggered and
<code class="language-plaintext highlighter-rouge">0</code> means edge triggered. Similarly the active polarity is configured by
the <code class="language-plaintext highlighter-rouge">*_irq_ioapic_polarity</code> attribute where a value of <code class="language-plaintext highlighter-rouge">1</code> means active
low and <code class="language-plaintext highlighter-rouge">0</code> means active high.</p>

<p>To change the previous example to connect an interrupt on I/O APIC 0, pin 2
that is edge triggered with active high polarity you would change</p>

<pre><code class="language-camkes">d.irq_irq_number = 2;
</code></pre>

<p>To become</p>

<pre><code class="language-camkes">d.irq_irq_type = "ioapic";
d.irq_irq_ioapic = 0;
d.irq_irq_ioapic_pin = 2;
d.irq_irq_ioapic_polarity = 0;
d.irq_irq_ioapic_level = 0;
d.irq_irq_vector = 42;
</code></pre>

<p>With the <code class="language-plaintext highlighter-rouge">vector</code> being arbitrarily chosen as <code class="language-plaintext highlighter-rouge">42</code></p>

<p>An interrupt that is edge triggered and active high can be more concisely
declared as an ISA interrupt by</p>

<pre><code class="language-camkes">d.irq_irq_type = "isa";
d.irq_irq_ioapic = 0;
d.irq_irq_ioapic_pin = 2;
d.irq_irq_vector = 42;
</code></pre>

<p>Similarly if this interrupt were to be level triggered and active low it
could be declared as a PCI interrupt by</p>

<pre><code class="language-camkes">d.irq_irq_type = "pci";
d.irq_irq_ioapic = 0;
d.irq_irq_ioapic_pin = 2;
d.irq_irq_vector = 42;
</code></pre>

<h5 id="io-ports">IO Ports</h5>

<p>The allowable range of IO Ports must be specified.
The example below specifies that the hardware component instance
<code class="language-plaintext highlighter-rouge">d</code> may access IO ports greater than or equal to 0x60, and less
than 0x64.</p>

<pre><code class="language-camkes">component Device {
  hardware;

  provides IOPort io_port;
  ...
}

assembly {
  composition {
    component Device d;
    ...
  }
  configuration {
    d.io_port_attributes = "0x60:0x64";
    ...
  }
}
</code></pre>

<h3 id="port-privileges">Port Privileges</h3>

<p>CAmkES allows the programmer to specify access rights that instances have over
the ports connecting them to other instances. This is done by setting the
<code class="language-plaintext highlighter-rouge">*_access</code> attribute of the port. The value of the attribute must be a string
containing the letters “R”, “W” and “X”, giving the port read, write and execute
privileges, respectively. If left unspecified, full access will be given.</p>

<p>In the example below, instance <code class="language-plaintext highlighter-rouge">f</code> has read-only access to <code class="language-plaintext highlighter-rouge">port_a</code>, and
instance <code class="language-plaintext highlighter-rouge">b</code> has read/write access to <code class="language-plaintext highlighter-rouge">port_a</code>. Instance <code class="language-plaintext highlighter-rouge">b</code> has read-only
access to <code class="language-plaintext highlighter-rouge">port_b</code>. Instance <code class="language-plaintext highlighter-rouge">a</code> has read/write/execute access to <code class="language-plaintext highlighter-rouge">port_b</code> even
though it’s not explicitly stated, as this is the default.</p>

<pre><code class="language-camkes">component Foo {
  dataport Buf data_a;
  dataport Buf data_b;
}

component Bar {
  dataport Buf data_a;
  dataport Buf data_b;
}

assembly {
  composition {
    component Foo f;
    component Bar b;
    ...
    connection seL4SharedData port_a(from f.data_a, to b.data_a);
    connection seL4SharedData port_b(from f.data_b, to b.data_b);
    ...
  }
  configuration {
    f.data_a_access = "R";
    b.data_a_access = "RW;
    f.data_b_access = "R";
    ...
  }
}
</code></pre>

<h3 id="thread-model">Thread Model</h3>

<p>CAmkES components are typically multithreaded and, to prevent race conditions,
it is often necessary to understand what threads exist in your system.</p>

<p>Firstly there is a single active thread. This is the thread of control that
calls the component’s entry point for components declared <code class="language-plaintext highlighter-rouge">control</code>. This
thread is present even in non-control components in order to perform
initialisation actions.</p>

<p>Each interface your component interacts with, either as an incoming or outgoing
interface, induces another thread within the component. Initial synchronisation
of these threads and their various setup activities is all handled by generated
code. Note that this per-interface thread is present even for interfaces that
you may think of as passive. For example, dataports. This is merely an
implementation artefact and may change in future.</p>

<p>One thing that may not be intuitive for users is that you have no guarantee as
to which thread will invoke an event callback. If you have registered a
callback for an event you are receiving, you should not assume that any
thread-local state persists between invocations. This is because the thread
which invokes a callback may not be the same thread as was used last time the
callback was invoked.</p>

<h3 id="thread-priorities">Thread Priorities</h3>

<p>Each thread in a CAmkES system has a priority that determines how it is
scheduled by seL4. These priorities default to a value given by the
<code class="language-plaintext highlighter-rouge">--default-priority</code> command-line argument to the runner. The higher number,
the higher thread’s priority, that is, a thread with priority 100 will be
executed before a thread with priority 90.</p>

<p>In a given system, it it possible to adjust the priority of a specific thread
with an attribute that has specific semantics. To adjust the priority of the
control thread (the thread that calls <code class="language-plaintext highlighter-rouge">run</code>), use the <code class="language-plaintext highlighter-rouge">_priority</code> attribute:</p>

<pre><code class="language-camkes">assembly {
  composition {
    component Foo f;
    ...
  }
  configuration {
    f._priority = 100;
  }
}
</code></pre>

<p>To adjust the priority of an interface thread, use an attribute named with the
name of the interface and the suffix ``_priority’’:</p>

<pre><code class="language-camkes">component Foo {
  uses MyInterface i;
}

assembly {
  composition {
    component Foo f;
    ...
  }
  configuration {
    f.i_priority = 100;
  }
}
</code></pre>

<p>If you want to adjust the priority of every thread within a given component
instance, you can use a general component attribute:</p>

<pre><code class="language-camkes">configuration {
  f.priority = 100;
}
</code></pre>

<p>For more information about the specifics of the seL4 scheduler, please refer to
the seL4 documentation.</p>

<h3 id="thread-cpu-affinity">Thread CPU affinity</h3>

<p>Each thread in a CAmkES system also has a processor affinity. This affinity will
by default bind all threads to CPU index 0, bootstrap-processor. In a system
where seL4 is built without multicore, setting this value above 0 is illegal.</p>

<pre><code class="language-camkes">component Mycomponent {
    /* ... */
    uses Myinterface i;
}

assembly {
    composition {
        component Mycomponent c;
    }
    configuration {
        /* Run all threads in "c" on CPU 1 */
        c.affinity = 1;
    }
}
</code></pre>

<p>Alternatively:</p>

<pre><code class="language-camkes">configuration {
    /* Run only the control thread on CPU 1, but run the rest of the threads
     * in this component on the "default" CPU (index 0).
     */
    c._affinity = 1;
}
</code></pre>

<p>Or perhaps:</p>

<pre><code class="language-camkes">configuration {
    /* Run only the interface thread for "i" on CPU 1, but run the rest of the
     * threads in this component on the "default" CPU (index 0).
     */
    c.i_affinity = 1;
}
</code></pre>

<h3 id="thread-stacks">Thread Stacks</h3>

<p>Each CAmkES thread has a stack provided for it for use at runtime, as is
typical. Stack size defaults to 4K, but this default can be adjusted through
the relevant build system configuration option. Additionally the stacks of
individual threads within a component can be set with attributes:</p>

<pre><code class="language-camkes">configuration {

  // Assign foo's control thread an 8K stack
  foo._stack_size = 8192;

  // Assign the interface thread for inf in foo a 16K stack
  foo.inf_stack_size = 16384;

}
</code></pre>

<p>Note that stacks must have a size that is 4K aligned, so if you assign a thread
a stack size that is not 4K aligned it will be rounded up. Stacks have a 4K
unmapped “guard page” either side of them. This is a debugging aid to force a
virtual memory fault when threads underrun or overrun their stacks.</p>

<h3 id="scheduling-domains">Scheduling Domains</h3>

<p>In CAmkES, it is possible to specify the domain each thread belongs to, by setting attributes.
Each interface of each component instance will have an associated thread, and
there will be an additional thread per-component to perform initialisation and
optionally act as the control thread. For interface threads, their domain can be
specified by setting the attribute <code class="language-plaintext highlighter-rouge">&lt;interface&gt;_domain</code> of the instance. For
control threads, the attribute <code class="language-plaintext highlighter-rouge">_domain</code> of the instance can be set.</p>

<pre><code class="language-camkes">component Foo {
  control;
  uses iface i;
}

component Bar {
  provides iface o;
}

assembly {
  composition {
    component Foo f;
    component Bar b;
    connection seL4RPCCall c(from f.i, to b.o);
    ...
  }
  configuration {
    f._domain = 0;  // domain of control thread of f
    b.o_domain = 1; // domain of o interface of b
    ...
  }
}
</code></pre>

<h3 id="userspace-rpc-transfer-buffers">Userspace RPC Transfer Buffers</h3>

<p>By default, the majority of RPC connectors exchange data through a
kernel-managed IPC buffer. RPC communication involving longer messages can be
optimised by exchanging data through userspace buffers instead of the IPC
buffer. To achieve this, set up an <code class="language-plaintext highlighter-rouge">seL4SharedData</code> connection and assign a
custom attribute:</p>

<pre><code class="language-camkes">component Foo {
  uses iface i;
  dataport Buf d;
}

component Bar {
  provides iface j;
  dataport Buf e;
}

assembly {
  composition {
    component Foo foo;
    component Bar bar;

    connection seL4RPCCall conn(from foo.i, to bar.j);
    connection seL4SharedData ubuf(from foo.d, to bar.e);
  }
  configuration {
    conn.buffer = "ubuf";
  }
}
</code></pre>

<p>There are a few limitations to be aware of when using this technique. The only
RPC connector that supports this style of userspace communication at time of
writing is <code class="language-plaintext highlighter-rouge">seL4RPCCall</code>. The RPC connection must be 1-to-1 and the
<code class="language-plaintext highlighter-rouge">seL4SharedData</code> connection must connect the same two component instances. The
size of the buffer (determined by the dataports’ type) is flexible, but if you
use a buffer that is too small to accommodate RPC data you will trigger runtime
errors during parameter marshalling.</p>

<h3 id="multi-assembly-applications">Multi-Assembly Applications</h3>

<p>CAmkES allows programmers to define an arbitrary number of assemblies for their application.
Different assemblies may appear in different files, provided that they are appropriately
included in the main ADL file. At compile time, the bodies of each
assembly are merged together, with all declared names remaining the same.
Thus, naming conflicts can occur on items declared in different assemblies.</p>

<pre><code class="language-camkes">assembly {
  composition {
    component Foo f;
  }
}

assembly {
  composition {
    component Bar b;
    connection seL4RPCCall c(from f.a, to b.a);
  }
  configuration {
    f.some_attribute = 0;
  }
}
</code></pre>

<p>The example above is equivalent to:</p>

<pre><code class="language-camkes">assembly {
  composition {
    component Foo f;
    component Bar b;
    connection seL4RPCCall c(from f.a, to b.a);
  }
  configuration {
    f.some_attribute = 0;
  }
}
</code></pre>

<h3 id="hierarchical-components">Hierarchical Components</h3>

<h4 id="syntax">Syntax</h4>

<p>A component definition may include a composition and configuration section.
The composition and configuration sections must be the last items in the component definition.
The composition and configuration sections may appear in any order. A composition section
can be included without a configuration, however a configuration section is only allowed
if there is a composition.</p>

<pre><code class="language-camkes">component Foo_Impl {
  provides iface_a a_impl;
  attribute string str;
}

component Foo {
  provides iface_a a;

  composition {
    component Foo_Impl fi;
    export fi.a_impl -&gt; a;
  }
  configuration {
    fi.str = "Hello, World!";
  }
}

component Bar {
  control;
  uses iface_a a;
}

assembly {
  composition {
    component Foo f;
    component Bar b;
    connection seL4RPCCall c(from b.a, to f.a);
  }
}
</code></pre>

<p>In the example above, the component <code class="language-plaintext highlighter-rouge">Foo</code> exposes a virtual interface <code class="language-plaintext highlighter-rouge">a</code>,
which is exported from the interface <code class="language-plaintext highlighter-rouge">a_impl</code> of the component instance <code class="language-plaintext highlighter-rouge">fi</code> of type <code class="language-plaintext highlighter-rouge">Foo_Impl</code>.</p>

<h4 id="hierarchy-resolution">Hierarchy Resolution</h4>

<p>Prior to compilation, the AST representing the system is transformed to remove all
hierarchical components. For each instance of a compound component, any internal instances
and internal connections declared
inside the component are copied into the top-level assembly with the compound component instance’s
name prepended to their own.
Each appearance of a virtual interface of some compound component instance
in a connection in the top-level assembly, is replaced
with the exported interface of the internal instance copied into the top-level assembly
while resolving that compound component instance.
Then, for each compound component, all virtual interfaces are removed.
If this results in any components with no interfaces, these components, and all instances
of such components, are removed from the specification.</p>

<p>The example above would be converted into the following:</p>

<pre><code class="language-camkes">component Foo_Impl {
  provides iface_a a_impl;
  attribute string str;
}

component Bar {
  control;
  uses iface_a a;
}
assembly {
  composition {
    component Bar b;
    component Foo_Impl f.fi;
    connection seL4RPCCall c(from b.a, to f.fi.a_impl);
  }
  configuration {
    f.fi.str = "Hello, World!";
  }
}
</code></pre>

<h4 id="examples">Examples</h4>

<h5 id="connecting-multiple-compound-components">Connecting multiple compound components</h5>

<p>It’s possible for both sides of a connection to be virtual interfaces:</p>

<pre><code class="language-camkes">component Foo_Impl {
  provides iface_a a_impl;
}

component Bar_Impl {
  uses iface_a a_usage;
}

component Foo {
  provides iface_a a;

  composition {
    component Foo_Impl fi;
    export fi.a_impl -&gt; a;
  }
}

component Bar {
  uses iface_a a;

  composition {
    component Bar_Impl bi;
    export bi.a_usage -&gt; a;
  }
}

assembly {
  composition {
    component Foo f;
    component Bar b;
    connection seL4RPCCall c(from b.a, to f.a);
  }
}
</code></pre>

<p>This example compiles to:</p>

<pre><code class="language-camkes">component Foo_Impl {
  provides iface_a a_impl;
}

component Bar_Impl {
  uses iface_a a_usage;
}

assembly {
  composition {
    component Foo_Impl f.fi;
    component Bar_Impl b.bi;
    connection seL4RPCCall c(from b.bi.a_usage, to f.fi.a_impl);
  }
}
</code></pre>

<h5 id="compound-component-with-non-virtual-interfaces">Compound component with non-virtual interfaces</h5>

<p>A component can have both virtual and implemented interfaces:</p>

<pre><code class="language-camkes">component Foo_Impl {
  provides iface_a a_impl;
}

component Foo {
  provides iface_a a;
  provides iface_b b;

  composition {
    component Foo_Impl fi;
    export fi.a_impl -&gt; a;
  }
}

component Bar {
  uses iface_a a;
  uses iface_b b;
}

assembly {
  composition {
    component Foo f;
    component Bar b;
    connection seL4RPCCall c(from b.a, to f.a);
    connection seL4RPCCall c(from b.b, to f.b);
  }
}
</code></pre>

<p>This example compiles to:</p>

<pre><code class="language-camkes">component Foo_Impl {
  provides iface_a a_impl;
}

component Foo {
  provides iface_b b;
}

component Bar {
  uses iface_a a;
  uses iface_b b;
}

assembly {
  composition {
    component Foo f;
    component Bar b;
    component Foo_Impl f.fi;
    connection seL4RPCCall c(from b.a, to f.fi.a_impl);
    connection seL4RPCCall c(from b.b, to f.b);
  }
}
</code></pre>

<h5 id="deeper-hierarchy">Deeper Hierarchy</h5>

<p>So far, each example has had a compound component containing only non-compound component instances.
It’s possible to have a hierarchy of components of an arbitrary depth.</p>

<pre><code class="language-camkes">component A_Piece1 {
  provides a_piece ap;
}

component A_Piece2 {
  uses a_piece ap;
  provides iface_a a_impl;
}

component Foo_Impl {
  provides iface_a a_impl;

  composition {
    component A_Piece1 a1;
    component A_Piece2 a2;
    connection seL4RPCCall c(from a1.ap, to a2.ap);
    export a2.a_impl -&gt; a_impl;
  }
}

component Foo {
  provides iface_a a;

  composition {
    component Foo_Impl fi;
    export fi.a_impl -&gt; a;
  }
}

component Bar {
  uses iface_a a;
}

assembly {
  composition {
    component Foo f;
    component Bar b;
    connection seL4RPCCall c(from b.a, to f.a);
  }
}
</code></pre>

<p>This example compiles to:</p>

<pre><code class="language-camkes">component A_Piece1 {
  provides a_piece ap;
}

component A_Piece2 {
  uses a_piece ap;
  provides iface_a a_impl;
}

component Bar {
  uses iface_a a;
}

assembly {
  composition {
    component Bar b;

    component A_Piece1 f.fi.a1;
    component A_Piece2 f.fi.a2;

    connection seL4RPCCall f.fi.c(from f.fi.a1.ap, to f.fi.a2.ap);
    connection seL4RPCCall c(from b.a, to f.fi.a2.a_impl);
  }
}
</code></pre>

<h3 id="hierarchical-attributes">Hierarchical Attributes</h3>

<p>Attributes of internal instances and internal connections declared in the composition section
of a compound component may be set to refer to attributes of that compound component. During
hierarchy resolution, values of referring attributes are set to copies of the values of
their corresponding referent attributes.</p>

<h4 id="syntax-1">Syntax</h4>

<p>The <code class="language-plaintext highlighter-rouge">&lt;-</code> operator is used to set an attribute to refer to another. Lines of the following form
may appear in the configuration section of a compound component:</p>

<pre><code class="language-camkes">entity_name.attribute_name &lt;- local_attribute_name;
</code></pre>

<p>Here, <code class="language-plaintext highlighter-rouge">entity_name</code> is the name of a component instance or connection declared in the component’s
composition section, <code class="language-plaintext highlighter-rouge">attribute_name</code> is the name of an attribute of the entity, and
<code class="language-plaintext highlighter-rouge">local_attribute_name</code> is the name of an attribute of the composition component.</p>

<h4 id="example">Example</h4>

<pre><code class="language-camkes">component B {
  ...
  attribute string b_str;
}

component A {
  ...
  attribute string a_str;

  composition {
    ...
    component B b;
  }
  configuration {
    ...
    b.b_str &lt;- a_str;
  }
}

assembly {
  composition {
    ...
    component A a;
  }
  configuration {
    ...
    a.a_str = "Hello, World!";
  }
}
</code></pre>

<p>This example is resolved to the following:</p>

<pre><code class="language-camkes">component B {
  ...
  attribute string b_str;
}

component A {
  ...
  attribute string a_str;
}

assembly {
  composition {
    ...
    component A a;
    component B a_b;
  }
  configuration {
    ...
    a.a_str = "Hello, World!";
    a_b.b_str = "Hello, World!";
  }
}
</code></pre>

<h3 id="custom-data-types">Custom Data Types</h3>

<p>CAmkES allows the definition of custom data types for procedure method arguments and ports.
Data types can be defined in C header files by typedefing a struct, enum or built-in type.
Sections of the application that refer to custom types must include the header file.</p>

<h4 id="procedures">Procedures</h4>

<p>Assume a data type <code class="language-plaintext highlighter-rouge">Vector</code> is defined in the file vector.h in the top level include directory of the application:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef _VECTOR_H_
#define _VECTOR_H_
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Vector</span><span class="p">;</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>A procedural interface could then be defined to use the type:</p>

<pre><code class="language-camkes">procedure algebra_iface {
  include &lt;vector.h&gt;;
  Vector add(Vector a, Vector b);
}
</code></pre>

<p>C source files that need access to this data type can include the file with:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>To make the build system aware of the header file, for each component that uses it, the following must be added
to the application’s <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> (replacing the name <code class="language-plaintext highlighter-rouge">Component</code> with the name of the component):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DeclareCAmkESComponent(Component INCLUDES include/vector.h)
</code></pre></div></div>

<h4 id="ports">Ports</h4>

<p>Assume a data type <code class="language-plaintext highlighter-rouge">IntArray</code> is defined in int_array.h in the top level include directory of the application:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef _INT_ARRAY_H_
#define _INT_ARRAY_H_
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="p">}</span> <span class="n">IntArray</span><span class="p">;</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>A component could declare a port of this type:</p>

<pre><code class="language-camkes">component A {
  control;

  include "int_array.h";
  dataport IntArray int_arr;
}
</code></pre>

<p>This would give the implementation access to a global pointer, which points to
an appropriately large region of memory for the data type:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="k">volatile</span> <span class="n">IntArray</span> <span class="o">*</span> <span class="n">int_arr</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="single-address-space-components-groups">Single Address Space Components (Groups)</h3>

<p>By default, each component instance in an application is given its own address
space. This is ideal for isolation, but this separation does not come for free
and inter-address space communication is necessarily more expensive than local
communication. To colocate two component instances in a single address space,
they can be grouped together:</p>

<pre><code class="language-camkes">assembly {
  composition {
    group my_group {
      component Foo foo;
      component Bar bar;
    }
  }
}
</code></pre>

<p>Any references to such instances now need to be qualified by their group name.
For example, to connect the above two instances:</p>

<pre><code class="language-camkes">...
connection seL4RPCCall conn(from my_group.foo.inf1,
  to my_group.bar.inf2);
...
</code></pre>

<p>When component instances are colocated, another connector becomes available.
The <code class="language-plaintext highlighter-rouge">seL4DirectCall</code> connector collapses RPC communication into a direct
function call. Its usage is identical to other connectors:</p>

<pre><code class="language-camkes">...
connection seL4DirectCall conn(from my_group.foo.inf1,
  to my_group.bar.inf2);
...
</code></pre>

<p>Using this connector between two components that are not colocated is incorrect
and will trigger an error.</p>

<h4 id="caveats">Caveats</h4>

<p>When colocating component instances in a single address space, the intent is
for the environment of the instances to be as close to indistinguishable as
possible (with the exception of performance characteristics) from full
separation. This abstraction is not perfect and there are some mechanisms that
have slightly different semantics when used in a single address space scenario
and in an isolated scenario.</p>

<p>Parameters of direction <code class="language-plaintext highlighter-rouge">out</code> of certain types are typically heap-located in an
isolated component instance. This is still true in a colocated environment, but
when using the <code class="language-plaintext highlighter-rouge">seL4DirectCall</code> connector, these are located in the <em>callee’s</em>
heap, not the caller’s as may be otherwise expected. Freeing one of these
pointers to the incorrect heap will result in heap corruption and should be
avoided. Conversely, <em>not</em> freeing this pointer will leak memory and should also
be avoided. The recommended technique to work around this is to introduce a back
channel to the callee when necessary:</p>

<pre><code class="language-camkes">procedure my_proc {
  /* The following procedure will return a parameter, `x`,
   * that is a pointer into the callee's heap. It cannot
   * be directly freed by the caller and needs to be
   * passed back to the callee.
   */
  void foo(out string x);

  /* We provide a back channel for this. */
  include &lt;stdint.h&gt;;
  void remote_free(uintptr_t p);
}

component Caller {
  control;
  uses my_proc f;
}

component Callee {
  provides my_proc g;
}

assembly {
  composition {
    component Caller caller;
    component Callee callee;

    connection seL4DirectCall conn(from caller.f, to callee.g);
  }
}
</code></pre>

<p>It is then possible to implement both components’ code in such a way that
memory is always freed to the correct heap:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Caller.c */</span>

<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
  <span class="n">f_foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"received %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">f_remote_free</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">x</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Callee.c */</span>

<span class="kt">void</span> <span class="nf">g_foo</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">g_remote_free</span><span class="p">(</span><span class="kt">uintptr_t</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">free</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is cumbersome, but at least allows one to write safe code. In a
continually evolving project, it may not be known in advance whether
<code class="language-plaintext highlighter-rouge">seL4DirectCall</code> will be used. In these situations, it is recommended to use a
free wrapper that detects where a pointer is hosted. In the case of a simple
static heap region (the default), a wrapper can be constructed as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Caller.c */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">safe_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* These symbols are defined by generated code and
   * specify the bounds of the heap.
   */</span>
  <span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">morecore_area</span><span class="p">;</span>
  <span class="k">extern</span> <span class="kt">size_t</span> <span class="n">morecore_size</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">morecore_area</span> <span class="o">&amp;&amp;</span>
      <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">p</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">morecore_area</span> <span class="o">+</span> <span class="n">morecore_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* The pointer is in our heap. */</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="cm">/* The pointer is in the callee's heap. */</span>
    <span class="n">f_remote_free</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
  <span class="n">f_foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"received %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">safe_free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The preceding discussion dealt with <code class="language-plaintext highlighter-rouge">out</code> parameters, but note that the same
issue exists on <em>both</em> sides of an <code class="language-plaintext highlighter-rouge">seL4DirectCall</code> connection using <code class="language-plaintext highlighter-rouge">inout</code>
parameters. That is, the argument to the callee and the final value to the
caller are both pointers that would normally point into a local heap, but now
potentially point into a remote heap.</p>

<p>As a result of toolchain limitations,
<a href="https://gcc.gnu.org/wiki/LinkTimeOptimization">link-time optimisations</a> cannot
be applied to a component group. If you have LTO enabled in your build settings
it will be ignored for component groups.</p>

<h3 id="global-include-directories">Global Include Directories</h3>

<p>CAmkES allows users to define a list of directories that will be searched
when resolving imports of .camkes files (components and interfaces).
<code class="language-plaintext highlighter-rouge">CAmkESAddImportPath(interfaces)</code> will append a directory to this search path.
There is an additional path for templates which can be modified by calling
<code class="language-plaintext highlighter-rouge">CAmkESAddTemplatesPath(templates)</code>. The repository global-components repository
is an example of these mechanisms being used to import components, interfaces
and templates into a project. The target project simply needs to include
<code class="language-plaintext highlighter-rouge">global-components.cmake</code> to enable these modules to be referred to from within
the project’s camkes files. Below is an example of importing global-components:</p>
<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_file</span><span class="p">(</span>GLOBAL_COMPONENTS_PATH global-components.cmake PATHS <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/projects/global-components/ CMAKE_FIND_ROOT_PATH_BOTH<span class="p">)</span>
<span class="nb">mark_as_advanced</span><span class="p">(</span>FORCE GLOBAL_COMPONENTS_PATH<span class="p">)</span>
<span class="nb">if</span><span class="p">(</span><span class="s2">"</span><span class="si">${</span><span class="nv">GLOBAL_COMPONENTS_PATH</span><span class="si">}</span><span class="s2">"</span> STREQUAL <span class="s2">"GLOBAL_COMPONENTS_PATH-NOTFOUND"</span><span class="p">)</span>
    <span class="nb">message</span><span class="p">(</span>FATAL_ERROR <span class="s2">"Failed to find global-components.cmake. Consider cmake -DGLOBAL_COMPONENTS_PATH=/path/to/global-components.cmake"</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>
<span class="nb">include</span><span class="p">(</span><span class="si">${</span><span class="nv">GLOBAL_COMPONENTS_PATH</span><span class="si">}</span><span class="p">)</span>

</code></pre></div></div>

<p>This allows one to place common components and interfaces in a central location
rather than duplicating them inside the application directory of each
application that uses them. Components and interfaces defined in global include
directories are known as <strong>Global Components</strong> and <strong>Global Interfaces</strong>.
When the distinction is necessary, non-global components and interfaces are
known as <strong>Local Components</strong> and <strong>Local Interfaces</strong>.</p>

<h4 id="recommended-practices">Recommended Practices</h4>

<p>Generally, a component should be created as a global component unless there’s
some good reason not to. Applications should consist of a (usually) small number
of control components, and possibly some application specific utility components.
When possible, utility components should be generalised and placed in a global
component repository.</p>

<p>All procedural interfaces used or provided by global components should be
global interfaces. Applications containing multiple local components which
communicate over procedural interfaces should define these interfaces locally,
unless it would make sense for these interfaces to generalise to other components
in the future, in which case they should be global interfaces.</p>

<p>Regarding header files defining custom data types, if the data type is specific to
a particular component or procedural interface, the header file should be placed
in the directory of that component or interface. Otherwise, header files should
be placed in a well known top-level subdirectory of the component repository so
they may be reused between components and interfaces.</p>

<p>It is possible that between global components, there is some shared functionality
such as commonly used algorithms and data structures. Rather than duplicating this
code across multiple global components, it should be placed in source/header files
in a well known top-level subdirectory of the component repository.</p>

<h3 id="cached-hardware-dataports">Cached Hardware Dataports</h3>

<p>By default, memory backing hardware dataports (<code class="language-plaintext highlighter-rouge">seL4HardwareMMIO</code>) is mapped uncached.
Typically such a dataport will be backed by a device’s memory mapped registers rather
than main memory. In such cases it’s generally desired that after writing to a register
the effect of the write is felt immediately, and changes to device registers are observable
as soon as they occur, so mapping this memory uncached makes sense. There are however,
cases where it is preferable to map this memory cached instead.</p>

<p>For example, consider a system that updates a large memory mapped frame buffer for
a display, by writing to it one word at a time. If this buffer was mapped uncached,
each word written to the buffer would incur the full time taken to write to memory.
If instead, the buffer was mapped cached, each word would be written to the cache,
incurring a much shorter write time. Cache lines would then be written back to memory
at a later point. This optimization works on the assumption that the throughput of
the cache being written back to memory is higher than that of the CPU writing
directly to memory a word at a time. After all the data has been written to the buffer,
the cache must be flushed to ensure the data is actually in the buffer.</p>

<p>CAmkES provides a mechanism for flushing the cache, but currently it is a no-op
on all architectures other than ARM. On x86, the DMA engine is cache-coherent,
so there’s no reason to explicitly flush the cache after writing to a cached
hardware dataport.</p>

<h4 id="marking-a-hardware-dataport-as-cached">Marking a hardware dataport as cached</h4>

<p>To map a hardware dataport cached, set the <code class="language-plaintext highlighter-rouge">&lt;instance&gt;.&lt;interface&gt;_hardware_cached</code> attribute to <code class="language-plaintext highlighter-rouge">true</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>component DisplayDevice {
  hardware;
  dataport FrameBuffer framebuffer;
}

component DisplayDriver {
  ...
  dataport FrameBuffer framebuffer;
}

assembly {
  composition {
    component DisplayDevice display_device;
    component DisplayDriver display_driver;
    ...

    connection seL4HardwareMMIO fbconn(
      from display_driver.framebuffer,
      to display_device.framebuffer
    );
  }
  configuration {
    ...
    display_device.framebuffer_hardware_cached = true; /* &lt;-- set this attribute
                                               *     to mark dataport
                                               *     as cached
                                               */
  }
}
</code></pre></div></div>

<h4 id="manipulating-the-cache">Manipulating the cache</h4>

<p>After writing to a cached hardware dataport, or potentially prior to reading from it,
it is necessary to manipulate the cache to ensure a consistent view of the memory
between the CPU and any devices. CAmkES provides a function for each hardware dataport
for doing cache operations on the range of addresses inside the dataport.</p>

<p>For a dataport interface named <code class="language-plaintext highlighter-rouge">framebuffer</code>, the function that operates on the cache
will be</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">framebuffer_cache_op</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">start_offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">dma_cache_op_t</span> <span class="n">cache_op</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">start_offset</code> and <code class="language-plaintext highlighter-rouge">size</code> are the offset in bytes into the dataport to start flushing,
and the number of bytes to flush respectively. <code class="language-plaintext highlighter-rouge">cache_op</code> is one of the three defined
cache operations: <code class="language-plaintext highlighter-rouge">DMA_CACHE_OP_CLEAN</code>, <code class="language-plaintext highlighter-rouge">DMA_CACHE_OP_INVALIDATE</code>, <code class="language-plaintext highlighter-rouge">DMA_CACHE_OP_CLEAN_INVALIDATE</code>.
The function returns 0 on success and non-zero on error</p>

<h2 id="templating">Templating</h2>

<p>CAmkES glue code, code automatically introduced into your component system at
compile time, is driven by a set of templates. These templates are instantiated
with values determined from your input ADL specification. CAmkES templates are
written as C code with Python snippets embedded in comments. This is all driven
by the <a href="http://jinja.pocoo.org/docs/">Jinja2</a> templating engine. You can see
examples of existing templates in camkes/templates/.</p>

<p>The remainder of this section gives advice for people intending to implement
their own templates or modify existing templates. If you are attempting to
modify the template context itself, you should instead refer to the
<a href="#template-context">Template Context</a> section.</p>

<h3 id="template-writing">Template Writing</h3>

<p>Inside a template you write C code as you would normally, but use the following
special comments to run Python code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/*- execute code -*/</code> (equivalent of Python’s <code class="language-plaintext highlighter-rouge">exec</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">/*? execute code and replace with result -*/</code> (equivalent of Python’s <code class="language-plaintext highlighter-rouge">eval</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">/*# a comment to be removed at instantiation #*/</code></li>
</ul>

<p>In general, when writing code in a template, refer to the Jinja documentation
syntax and functionality. Note that the default Jinja delimiters have been modified
to <code class="language-plaintext highlighter-rouge">/*</code> and <code class="language-plaintext highlighter-rouge">*/</code> to let syntax highlighting in C work more naturally.</p>

<p>Within a given template you have a variable <code class="language-plaintext highlighter-rouge">me</code> that functions like native
Python’s <code class="language-plaintext highlighter-rouge">self</code>. It refers to the object of relevance to the current template.
So, for example, during instantiation of the component source file, it refers
to the component instance being instantiated. In certain general “top-level”
templates, there is no particular “subject.” In these templates, for example
<code class="language-plaintext highlighter-rouge">camkes-gen.cmake</code>, <code class="language-plaintext highlighter-rouge">me</code> will be <code class="language-plaintext highlighter-rouge">None</code>.</p>

<p>The template context is a limited subset of Python. It is relatively easy
to extend, and if you intend to do this you can see how in the
<a href="#template-context">Template Context</a> section. Some statements in
Python could not be cleanly exposed and so have instead become functions. In
particular, be aware of quirks in assertions, lambdas and exceptions. <code class="language-plaintext highlighter-rouge">assert</code>
is available as a function. So instead of writing <code class="language-plaintext highlighter-rouge">assert foo == 1</code> you would
write <code class="language-plaintext highlighter-rouge">assert(foo == 1)</code>.</p>

<p>Lambdas are perhaps more confusing. Instead of writing
<code class="language-plaintext highlighter-rouge">lambda x: x.startswith('hello')</code> you would write
<code class="language-plaintext highlighter-rouge">lambda('x: x.startswith(\'hello\')'</code>. Note that you lose some type safety and
expressivity here, but there did not seem to be a nicer way to expose this.
Exceptions are now also raised by function. So instead of writing
<code class="language-plaintext highlighter-rouge">raise Exception('foo')</code> you would write <code class="language-plaintext highlighter-rouge">raise(Exception('foo'))</code>.</p>

<p>For the specific functionality available in the template context, it may be
helpful to refer to the file camkes/runner/Context.py. Note that in the
template context you also have access to the command line options via <code class="language-plaintext highlighter-rouge">options</code>
as well.</p>

<h3 id="idioms">Idioms</h3>

<p>There are certain common operations you may wish to perform inside a template
context, for which idioms have developed. This section documents some of these
snippets of code that may look unusual when you first encounter them.</p>

<h4 id="passing-information-between-templates">Passing Information Between Templates</h4>

<p>You often wish to do this with two related templates. For example, in the
templates that form each side of a connection you often wish to talk about the
same object on both sides. None of the templates currently call the low-level
helper functions that enable this directly, but if you do want to invoke them,
they are <code class="language-plaintext highlighter-rouge">stash</code> and <code class="language-plaintext highlighter-rouge">pop</code>. <code class="language-plaintext highlighter-rouge">stash</code> lets you save a Python object under a given
key name and <code class="language-plaintext highlighter-rouge">pop</code> retrieves a previously saved Python object by key. Note that
these are only usable for passing objects between templates that share related
<code class="language-plaintext highlighter-rouge">me</code> references.</p>

<h4 id="generating-symbol-names">Generating Symbol Names</h4>

<p>Within a C template you sometimes need a temporary variable in a context in
which user-provided variables may be in scope. That is, you need a named symbol
but you need to ensure it doesn’t collide with any existing user symbols. To do
this you can call the function <code class="language-plaintext highlighter-rouge">c_symbol</code>. This generates a pseudo-unique name
that you can use from then on. For example,</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*- set my_var = c_symbol() -*/</span>
<span class="kt">int</span> <span class="cm">/*? my_var ?*/</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">c_symbol</code> takes an optional string argument that will make that string part of
the resulting symbol name. This is helpful for debugging purposes if you want
to give someone looking at the instantiated template a visual clue as to the
purpose of a temporary variable.</p>

<h4 id="subverting-scoping">Subverting Scoping</h4>

<p>Jinja has some unusual and often counter-intuitive variable scoping rules.
Occasionally templates wish to conditionally assign to a variable within the
context of a loop or other Jinja block. In these circumstances it can be tricky
to get the write to propagate outside the loop. You may see a temporary array
and a <code class="language-plaintext highlighter-rouge">do</code> construct used in these situations:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*- set temp = [None] -*/</span>
<span class="cm">/*- for .... -*/</span>
  <span class="p">...</span>
  <span class="cm">/*- if ... -*/</span>
    <span class="cm">/*- do temp.__setitem__(0, True) -*/</span>
  <span class="cm">/*- else -*/</span>
    <span class="cm">/*- do temp.__setitem__(0, False) -*/</span>
  <span class="cm">/*- endif -*/</span>
  <span class="p">...</span>
<span class="cm">/*- endfor -*/</span>
<span class="cm">/*- set variable_we_want_to_set = temp[0] -*/</span>
</code></pre></div></div>

<h3 id="reply-capabilities">Reply Capabilities</h3>

<p>The seL4 system call, <code class="language-plaintext highlighter-rouge">seL4_Call</code>, generates transient capabilities called
reply capabilities (see the seL4 documentation for more specific details). Care
must be taken when writing template code in order to avoid interfering with the
functionality of another piece of template code that may have created reply
capabilities. If you are not using reply capabilities yourself, there is a
simple rule to remember:</p>

<ul>
  <li>always call <code class="language-plaintext highlighter-rouge">camkes_protect_reply_cap()</code> before performing an operation that
would cause a wait on a synchronous endpoint.</li>
</ul>

<p>This call is idempotent (you can call it multiple times in sequence with no ill
effects), though be aware it may modify the contents of your IPC buffer. You
do not need to perform this operation when sending on a synchronous endpoint or
waiting on a notification, however it <em>is</em> necessary when performing
batched system calls like <code class="language-plaintext highlighter-rouge">seL4_ReplyRecv</code> or <code class="language-plaintext highlighter-rouge">seL4_Call</code> on a synchronous
endpoint.</p>

<p>If you are <em>receiving</em> reply capabilities in your own template and calling
external functionality before using them, you need to be aware that they can be
overwritten when execution is outside your template. To safe guard yourself
against this, there is a complementary rule:</p>

<ul>
  <li>always call <code class="language-plaintext highlighter-rouge">camkes_declare_reply_cap(...)</code> when you have just received a
reply capability.</li>
</ul>

<p>Note that you need to pass this function an empty capability slot into which to
save the reply capability if it is about to be overwritten. In order to support
saving of this reply capability on demand, CAmkES needs a capability to the
current thread’s CNode. This needs to be setup by your template code. Some
variant of the following code needs to be executed for each thread that could
receive a reply capability:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*# Allocate a cap to our own CNode. #*/</span>
<span class="cm">/*- set cnode = alloc_cap('cnode', my_cnode) -*/</span>
<span class="cm">/* Configure a TLS pointer to our own CNode cap. */</span>
<span class="n">camkes_get_tls</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cnode_cap</span> <span class="o">=</span> <span class="cm">/*? cnode ?*/</span><span class="p">;</span>
</code></pre></div></div>

<p>When you need to use a reply capability you have protected, you should check
the <code class="language-plaintext highlighter-rouge">reply_cap_in_tcb</code> member of the CAmkES TLS structure and, if the capability
is no longer in your TCB, call <code class="language-plaintext highlighter-rouge">camkes_unprotect_reply_cap()</code> and deal with any
possible error that may have occurred. The functional API for dealing with
reply capabilities is provided below. Though this is technically part of the
<a href="#runtime-api">runtime API</a>, it is included here because user code is never
expected to call these functions.</p>

<p><strong><code class="language-plaintext highlighter-rouge">int camkes_declare_reply_cap(seL4_CPtr shadow_slot)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/tls.h&gt;</code>)</p>

<blockquote>
  <p>Identify to the CAmkES library that you are in possession of a reply
  capability in your TCB. CAmkES only handles a single reply capability
  currently and, as such, you should not call this function when you have
  previously declared a pending reply capability you have not yet discarded.
  This essentially says to CAmkES, “I have a reply cap in my TCB; please save
  it to <code class="language-plaintext highlighter-rouge">shadow_slot</code> if it is in risk of being deleted.”</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">void camkes_protect_reply_cap(void)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/tls.h&gt;</code>)</p>

<blockquote>
  <p>Guard any potential pending reply capability against deletion by saving it
  now. Note that this function accepts no arguments and returns nothing. It is
  designed to be called unconditionally from generated code that believes it
  may be about to overwrite a reply capability. There is no point providing a
  result to the caller because the caller is not the conceptual “owner” of
  the capability and does not know how to deal with a failure to protect it.
  You should always call this code in your template if you believe a reply
  capability could be present and the operation you are about to perform has a
  chance of deleting it.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">seL4_Error camkes_unprotect_reply_cap(void)</code></strong> (<code class="language-plaintext highlighter-rouge">#include &lt;camkes/tls.h&gt;</code>)</p>

<blockquote>
  <p>Discard any information relating to a current pending reply capability. This
  is designed to be called by the original declarer of a reply capability when
  it is about to use (or discard) that capability. Note that this returns a
  potential error that was encountered when some intermediate code tried to
  protect the capability and it failed. The return value is essentially a
  result from <code class="language-plaintext highlighter-rouge">seL4_CNode_SaveCaller</code>. This should <em>only</em> be called when you
  know the reply cap you need is no longer in your TCB. That is, you should
  check the <code class="language-plaintext highlighter-rouge">reply_cap_in_tcb</code> member of the CAmkES TLS structure to determine
  if calling this function is necessary.</p>
</blockquote>

<p>To get a more concrete idea of how these functions are used, you can refer to
the seL4RPCCall connector that uses this mechanism.</p>

<p>One final thing to note is that this functionality assumes cooperative
templates. There is nothing to prevent a malicious template omitting a call to
<code class="language-plaintext highlighter-rouge">camkes_protect_reply_cap()</code> and wilfully destroying pending reply
capabilities.</p>

<h3 id="template-debugging">Template Debugging</h3>

<p>If you are writing complicated template logic and need to debug during
instantiation, you can insert breakpoints into your template. These can be
inserted as either <code class="language-plaintext highlighter-rouge">/*- breakpoint() -*/</code> or <code class="language-plaintext highlighter-rouge">/*? breakpoint() ?*/</code>. When
encountered during instantiation they will drop you into the Python
interpreter, from where you can explore <code class="language-plaintext highlighter-rouge">me</code> and other local variables.</p>

<p>When prototyping or debugging more complicated problems it can be helpful to
have the ability to run arbitrary Python in the template context. There is some
limited support for this, with the functions <code class="language-plaintext highlighter-rouge">exec</code> and <code class="language-plaintext highlighter-rouge">eval</code>. These operate
like the native Python <code class="language-plaintext highlighter-rouge">exec</code> and <code class="language-plaintext highlighter-rouge">eval</code>, but may be a little more fragile.
Note that <code class="language-plaintext highlighter-rouge">exec</code> is a function in this context, not a statement. So where you
would normally write <code class="language-plaintext highlighter-rouge">exec 'print \'hello\''</code> you would write
<code class="language-plaintext highlighter-rouge">exec('print \'hello\'')</code>.</p>

<p>Although never advisable in a proper implementation, it is possible to pass
arbitrary information between unrelated templates. Similar to the <code class="language-plaintext highlighter-rouge">stash</code> and
<code class="language-plaintext highlighter-rouge">pop</code> functions described above, there are lower level versions, <code class="language-plaintext highlighter-rouge">_stash</code> and
<code class="language-plaintext highlighter-rouge">_pop</code> that let you write to and read from a context that propagates across all
templates. Note that you can only use this to pass information “forwards” to
templates that are instantiated after the one you are calling <code class="language-plaintext highlighter-rouge">_stash</code> from.</p>

<h2 id="developers">Developers</h2>

<p>This section is targeted at those intending to modify the CAmkES implementation
itself. The information below assumes you are familiar with the features and
functionality of CAmkES.</p>

<p>If you are modifying the actual sources of any of the CAmkES modules I’ve
attempted
to leave helpful comments. I’ve occasionally used tags in the comments that
may help you when grepping and whatnot. They mean:</p>

<p><strong>FIXME</strong></p>

<blockquote>
  <p>This is a stop gap piece of functionality that should be replaced
  with something more feature complete when time permits. This could also refer
  to an existing bug that cannot currently be easily remedied.</p>
</blockquote>

<p><strong>HACK</strong></p>

<blockquote>
  <p>This code is a bit dubious, but is intentionally written this way to
  work around limitations in some other tool outside our control.</p>
</blockquote>

<p><strong>MOVE</strong></p>

<blockquote>
  <p>This is the wrong place for this piece of functionality. It should
  be refactored somewhere else.</p>
</blockquote>

<p><strong>PERF</strong></p>

<blockquote>
  <p>This code is structured in a counter-intuitive or non-obvious way for
  performance reasons. Refactor if you wish, but be aware it may have a
  significant impact on runtime.</p>
</blockquote>

<p><strong>SLOW</strong></p>

<blockquote>
  <p>This code is known to be inefficient, but was deliberately written
  this way for simplicity. If you are hitting performance problems and looking
  for optimisation opportunities try grepping for this.</p>
</blockquote>

<p><strong>TODO</strong></p>

<blockquote>
  <p>Some part of the functionality in this section has not yet been
  implemented or the code could be improved in some way.</p>
</blockquote>

<p><strong>XXX</strong></p>

<blockquote>
  <p>There is something out of the ordinary about this piece of code that
  should probably be fixed. This is often in cases where I didn’t have time to
  write a proper <strong>FIXME</strong> or <strong>TODO</strong> comment.</p>
</blockquote>

<h3 id="parser-internals">Parser Internals</h3>

<ul>
  <li>camkes/parser/*</li>
</ul>

<p>The previous section, <a href="#camkesparser">camkes.parser</a>, describes the high-level
interface to the CAmkES parser. This parser is assembled from a pipeline of
lower-level parsers. These are each described as a “stage” in parsing. To
understand them, it is necessary to understand a few variants of Abstract
Syntax Tree representations that are referred to in the source code. The
following representations are described in order from least to most abstract:</p>

<ul>
  <li><strong>Augmented input</strong> This is not an AST, as such, but rather a tuple of source
data and a set of read files.</li>
  <li><strong>Raw AST</strong> This is a tree of <code class="language-plaintext highlighter-rouge">plyplus.stree</code>s.</li>
  <li><strong>Augmented AST</strong> This is a list of <code class="language-plaintext highlighter-rouge">plyplus.stree</code>s with attached
information about their original source data and the file they came from.</li>
  <li><strong>Lifted AST</strong> This is the most abstract programmatic representation of an
input specification and the form developers will come to be most familiar
with. It is a tree of objects from <a href="#camkesast">camkes.ast</a>.</li>
</ul>

<p>The various low-level parsers are each responsible for a specific AST
transformation, with the high-level parser stringing them all together for ease
of use. The low-level parsers are:</p>

<ul>
  <li><strong>Stage 0</strong> Reads an input file and optionally runs the C pre-processor over
it. This “parser” is really just a more full featured version of the <code class="language-plaintext highlighter-rouge">open</code>
call.</li>
  <li><strong>Stage 1</strong> Parses input using <code class="language-plaintext highlighter-rouge">plyplus</code>. Note that this is where the CAmkES
grammar (camkes/parser/camkes.g) comes into play.</li>
  <li><strong>Stage 2</strong> Resolves <code class="language-plaintext highlighter-rouge">import</code> statements. This parser repeatedly calls back
into the stage 1 parser to parse further sources. Note that from here on,
<code class="language-plaintext highlighter-rouge">import</code> statements do not appear in the AST.</li>
  <li><strong>Stage 3</strong> Lifts the <code class="language-plaintext highlighter-rouge">plyplus</code> AST into the objects of
<a href="#camkesast">camkes.ast</a>. This is generally the most intensive parse phase
and inherently the most fragile as it encodes much of the semantics of the
CAmkES input language.</li>
  <li><strong>Stage 4</strong> Resolves semantic references. From here on, no
<code class="language-plaintext highlighter-rouge">camkes.ast.Reference</code>s remain in the AST.</li>
  <li><strong>Stage 5</strong> Collapses <code class="language-plaintext highlighter-rouge">group</code>s. The <code class="language-plaintext highlighter-rouge">group</code> keyword is used to colocate
component instances into a single address space. This stage removes groups
from the AST, assigning the same address space to their contained instances.</li>
  <li><strong>Stage 6</strong> Combines multiple assemblies. It is possible for more than one
<code class="language-plaintext highlighter-rouge">assembly</code> block to be specified in a CAmkES input specification, in which
case the intended assembly is the concatenation of all of them. This stage
performs that concatenation.</li>
  <li><strong>Stage 7</strong> Flattens component hierarchies. Component instances that are
nested inside other components are hoisted to the top-level assembly by this
stage.</li>
  <li><strong>Stage 8</strong> Resolves attribute references. Settings can be given a value that
references another attribute (using the <code class="language-plaintext highlighter-rouge">&lt;-</code> operator). This stage resolves
these references to concrete values.</li>
  <li><strong>Stage 9</strong> Freezes the AST. This stage transforms various AST internal data
structures into optimised forms and makes AST modification from this point on
impossible.</li>
</ul>

<p>With this information, looking back at the high-level parser, one can see that
it simply chains these stages together. It is possible to programmatically
construct a differing or partial parser by composing the low-level parsers in a
different manner.</p>

<h4 id="pre-compiled-templates">Pre-Compiled Templates</h4>

<ul>
  <li>camkes/runner/Renderer.py</li>
</ul>

<p>The Jinja templating engine works by compiling template code to native Python
code, which it then runs to produce the generated output. This compilation to
Python code is normally performed in each execution. To speed up this process,
when caching is enabled, the templates are compiled to the cache directory. In
future executions, template rendering optimistically fetches pre-compiled
templates from this cache. On a cache miss, it falls back to the original
template sources.</p>

<h3 id="template-context">Template Context</h3>

<p>The code that renders the templates themselves is all contained under the
runner directory in the CAmkES module. While the rendering itself is driven
from Renderer.py, the more relevant file is actually Context.py. The
<code class="language-plaintext highlighter-rouge">new_context</code> function returns a dictionary that defines the template
environment, that is, what local variables are present in the template at
instantiation time.</p>

<p>There is some fairly complex functionality here aimed at providing nice
abstractions to template authors. In particular, <code class="language-plaintext highlighter-rouge">alloc_obj</code>, <code class="language-plaintext highlighter-rouge">alloc_cap</code>,
<code class="language-plaintext highlighter-rouge">stash</code>, <code class="language-plaintext highlighter-rouge">pop</code> and <code class="language-plaintext highlighter-rouge">guard</code> are intended to provide an abstraction for the
template author to pass variables between templates. Refer to the comments in
this file to understand more about the template context.</p>

<p>Extending the context can be done by adding more items to this dictionary and
there aren’t many gotchas here. If you’re doing something more complicated than
exposing an existing built-in and having difficulty you may find the
implementations of <code class="language-plaintext highlighter-rouge">breakpoint</code> or <code class="language-plaintext highlighter-rouge">exec</code> informative as examples.</p>

<h3 id="core-libraries">Core Libraries</h3>

<p>CAmkES has a notion of “core libraries” as the set of seL4 libraries that may
be relied on to be available from within the template context. These are
defined within the camkes-gen.cmake template. This set of libraries has been extended on demand to cover all
base seL4 infrastructure. This can be freely expanded to cover more libraries
with no expected surprises.</p>

<p>Be aware that these libraries will be unconditionally depended upon and linked
into all CAmkES components. That is, the user’s lists of libraries defined in
their application CMakeLists.txt will all be silently extended to include the core
libraries.</p>

<h3 id="testing">Testing</h3>

<p>CAmkES has a set of unit tests and a set of integration tests. The unit tests
are structured per-module, with each module’s tests in a subdirectory of its
source:</p>

<ul>
  <li>camkes/ast/tests</li>
  <li>camkes/internal/tests</li>
  <li>camkes/parser/tests</li>
  <li>camkes/runner/tests</li>
  <li>camkes/templates/tests</li>
</ul>

<p>The unit tests use Python’s
<a href="https://docs.python.org/2/library/unittest.html">unittest</a> framework. The
simplest way to execute them is from the top-level wrapper script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./alltests.py
</code></pre></div></div>

<p>Alternatively, any finer granularity of test cases may be selected:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run all AST unit tests</span>
./camkes/ast/tests/runall.py

<span class="c"># Run only AST hashing assumption tests</span>
./camkes/ast/tests/runall.py TestHashingAssumptions

<span class="c"># Run only the specific test for hashing None</span>
./camkes/ast/tests/runall.py TestHashingAssumptions.test_none
</code></pre></div></div>

<p>The integration tests are contained in the CAmkES project repository under the
directory tests/. Again, the simplest way to execute these is with a wrapper
script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./tests/run-all.py
</code></pre></div></div>

<p>Alternatively, you can run individual integration tests:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Test simple RPC</span>
./tests/arm-simple.tcl
</code></pre></div></div>


</div>

            </main>
          </div>
          
          <div id="toc-open" class="absolute top-20 right-8 text-light hidden sm:block cursor-pointer">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-5 w-5 stroke-2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 15 12 18.75 15.75 15m-7.5-6L12 5.25 15.75 9"/>
</svg>
          </div>
          <nav id="the-toc"
               class="hidden xl:block absolute top-12 right-0 mt-8 pr-2 mr-6 w-60 h-[calc(100%-12rem)]
                      std-bg">
            <div class="pl-4 font-semibold mb-4 text-base text-dark relative">
              On this page
              <div id="toc-close" class="absolute top-1 right-1 text-light cursor-pointer">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-4 w-4 stroke-2">
  <path stroke-linecap="round" stroke-linejoin="round" d="m4.5 15.75 7.5-7.5 7.5 7.5"/>
</svg>
              </div>
            </div>
            <div class="pl-4 border-l bordercol overflow-y-auto max-h-full pb-2">
            <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#terminology">Terminology</a></li>
<li class="toc-entry toc-h2"><a href="#usage">Usage</a>
<ul>
<li class="toc-entry toc-h3"><a href="#dependencies">Dependencies</a></li>
<li class="toc-entry toc-h3"><a href="#tutorial">Tutorial</a>
<ul>
<li class="toc-entry toc-h4"><a href="#running-a-simple-example">Running a Simple Example</a></li>
<li class="toc-entry toc-h4"><a href="#creating-an-application">Creating An Application</a></li>
<li class="toc-entry toc-h4"><a href="#under-the-hood">Under the Hood</a></li>
<li class="toc-entry toc-h4"><a href="#an-example-of-events">An Example of Events</a></li>
<li class="toc-entry toc-h4"><a href="#an-example-of-dataports">An Example of Dataports</a></li>
<li class="toc-entry toc-h4"><a href="#an-example-of-structs-and-arrays-for-collections">An example of structs and arrays for collections</a></li>
<li class="toc-entry toc-h4"><a href="#tutorial-summary">Tutorial Summary</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#overview">Overview</a></li>
<li class="toc-entry toc-h3"><a href="#command-line-arguments">Command Line Arguments</a></li>
<li class="toc-entry toc-h3"><a href="#modules">Modules</a>
<ul>
<li class="toc-entry toc-h4"><a href="#camkesast">camkes.ast</a></li>
<li class="toc-entry toc-h4"><a href="#camkesparser">camkes.parser</a></li>
<li class="toc-entry toc-h4"><a href="#camkestemplates">camkes.templates</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#runtime-api">Runtime API</a></li>
<li class="toc-entry toc-h3"><a href="#synchronization-primitives">Synchronization Primitives</a></li>
<li class="toc-entry toc-h3"><a href="#direct-memory-access">Direct Memory Access</a>
<ul>
<li class="toc-entry toc-h4"><a href="#efficient-dma">Efficient DMA</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#error-handling">Error Handling</a></li>
<li class="toc-entry toc-h3"><a href="#custom-attributes">Custom Attributes</a>
<ul>
<li class="toc-entry toc-h4"><a href="#attributes-conversion-to-literal">Attribute’s conversion to literal</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#hardware-components">Hardware Components</a>
<ul>
<li class="toc-entry toc-h4"><a href="#configuration">Configuration</a>
<ul>
<li class="toc-entry toc-h5"><a href="#mmio">MMIO</a></li>
<li class="toc-entry toc-h5"><a href="#interrupts">Interrupts</a></li>
<li class="toc-entry toc-h5"><a href="#io-ports">IO Ports</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#port-privileges">Port Privileges</a></li>
<li class="toc-entry toc-h3"><a href="#thread-model">Thread Model</a></li>
<li class="toc-entry toc-h3"><a href="#thread-priorities">Thread Priorities</a></li>
<li class="toc-entry toc-h3"><a href="#thread-cpu-affinity">Thread CPU affinity</a></li>
<li class="toc-entry toc-h3"><a href="#thread-stacks">Thread Stacks</a></li>
<li class="toc-entry toc-h3"><a href="#scheduling-domains">Scheduling Domains</a></li>
<li class="toc-entry toc-h3"><a href="#userspace-rpc-transfer-buffers">Userspace RPC Transfer Buffers</a></li>
<li class="toc-entry toc-h3"><a href="#multi-assembly-applications">Multi-Assembly Applications</a></li>
<li class="toc-entry toc-h3"><a href="#hierarchical-components">Hierarchical Components</a>
<ul>
<li class="toc-entry toc-h4"><a href="#syntax">Syntax</a></li>
<li class="toc-entry toc-h4"><a href="#hierarchy-resolution">Hierarchy Resolution</a></li>
<li class="toc-entry toc-h4"><a href="#examples">Examples</a>
<ul>
<li class="toc-entry toc-h5"><a href="#connecting-multiple-compound-components">Connecting multiple compound components</a></li>
<li class="toc-entry toc-h5"><a href="#compound-component-with-non-virtual-interfaces">Compound component with non-virtual interfaces</a></li>
<li class="toc-entry toc-h5"><a href="#deeper-hierarchy">Deeper Hierarchy</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#hierarchical-attributes">Hierarchical Attributes</a>
<ul>
<li class="toc-entry toc-h4"><a href="#syntax-1">Syntax</a></li>
<li class="toc-entry toc-h4"><a href="#example">Example</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#custom-data-types">Custom Data Types</a>
<ul>
<li class="toc-entry toc-h4"><a href="#procedures">Procedures</a></li>
<li class="toc-entry toc-h4"><a href="#ports">Ports</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#single-address-space-components-groups">Single Address Space Components (Groups)</a>
<ul>
<li class="toc-entry toc-h4"><a href="#caveats">Caveats</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#global-include-directories">Global Include Directories</a>
<ul>
<li class="toc-entry toc-h4"><a href="#recommended-practices">Recommended Practices</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#cached-hardware-dataports">Cached Hardware Dataports</a>
<ul>
<li class="toc-entry toc-h4"><a href="#marking-a-hardware-dataport-as-cached">Marking a hardware dataport as cached</a></li>
<li class="toc-entry toc-h4"><a href="#manipulating-the-cache">Manipulating the cache</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#templating">Templating</a>
<ul>
<li class="toc-entry toc-h3"><a href="#template-writing">Template Writing</a></li>
<li class="toc-entry toc-h3"><a href="#idioms">Idioms</a>
<ul>
<li class="toc-entry toc-h4"><a href="#passing-information-between-templates">Passing Information Between Templates</a></li>
<li class="toc-entry toc-h4"><a href="#generating-symbol-names">Generating Symbol Names</a></li>
<li class="toc-entry toc-h4"><a href="#subverting-scoping">Subverting Scoping</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#reply-capabilities">Reply Capabilities</a></li>
<li class="toc-entry toc-h3"><a href="#template-debugging">Template Debugging</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#developers">Developers</a>
<ul>
<li class="toc-entry toc-h3"><a href="#parser-internals">Parser Internals</a>
<ul>
<li class="toc-entry toc-h4"><a href="#pre-compiled-templates">Pre-Compiled Templates</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#template-context">Template Context</a></li>
<li class="toc-entry toc-h3"><a href="#core-libraries">Core Libraries</a></li>
<li class="toc-entry toc-h3"><a href="#testing">Testing</a></li>
</ul>
</li>
</ul>
            </div>
            <div class="h-22"></div>
          </nav>
          
<footer class="flex-none flex flex-row py-6 pl-8 pr-10 border-t-1 bordercol
               text-xs lg:text-sm font-semibold text-lighter">
  <a href="/sitemap.html"
     class="flex-none hover:text-light hover:underline">Sitemap</a>
  <a href="/processes/test-status.html"
     class="mx-1 px-1 lg:mx-2 lg:px-2 bordercol border-l-2 flex-none hover:text-light hover:underline">Test status</a>
  <div class="flex-1"></div>
<a href="https://github.com/seL4/camkes-tool/edit/master/docs/index.md" class="flex-none  hover:text-light hover:underline">Edit
   included page on GitHub</a>
</footer>

        </div>
        </div>
    </div>
  </body>
</html>
