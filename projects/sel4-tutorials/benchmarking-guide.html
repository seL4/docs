<!DOCTYPE html>
<!--
     SPDX-License-Identifier: CC-BY-SA-4.0
     SPDX-FileCopyrightText: 2020 seL4 Project a Series of LF Projects, LLC.
-->
<!-- Page last generated 2025-03-02 03:18:37 +0000 -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Benchmarking seL4 | seL4 docs</title>

    <!-- Our stylesheet and theme stylesheet.  Contains bootstrap. -->
    <link rel="stylesheet" href="/assets/css/style.css" type="text/css">
    <!-- Font awesome -->
    <link href="https://use.fontawesome.com/releases/v5.0.8/css/all.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <!-- Pygments syntax highlighting  -->
    <link rel="stylesheet" href="/assets/css/highlighting/trac.css" type="text/css">
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico"><script defer data-domain="docs.sel4.systems"
	    src="https://analytics.sel4.systems/js/script.js"></script></head>

  <body class="container-fluid">

    



<header>
  <ul class="row menu">
    <li class="col-xs-12 col-md-2" >
            <a href="https://sel4.systems" class="skip-icon">
              <img class="img-responsive" src="/assets/logo-text-white.svg" alt="seL4 logo" />
            </a>
    </li>
    <li class="col-xs-12 col-md-10 menu">
      <nav aria-label="Banner links">
        <h2><a href="/Resources" />Resources</h2>
        <h2><a href="/processes" />Contributing</a></h2>
        <h2><a href="/projects" />Projects</h2>
        <h2><a href="/Tutorials" />Tutorials</h2>
        <iframe title="DuckDuckGo search bar" src="https://duckduckgo.com/search.html?site=docs.sel4.systems&prefill=Search%20sel4.systems" style="overflow:hidden;margin-bottom:10px; padding:0;height:40px;float:right;border-width: 0px"></iframe>
      </nav>
    </li>
  </ul>
  <div class="clear"></div>
  
<div class="breadcrumbs bootstrap hidden-sm-down">
  <nav class="sel-breadcrumb" aria-label="Breadcrumb" >
    <ol class=" list-unstyled" vocab="http://schema.org/" typeof="BreadcrumbList">
      
      
        

        

        <li class="breadcrumb-item" property="itemListElement" typeof="ListItem">
            <a property="item" typeof="WebPage" href="/">
              <span property="name"><b>seL4 Docs</b></span>
            </a>
            <meta property="position" content="1" />
        </li>
      
        

        

        <li class="breadcrumb-item" property="itemListElement" typeof="ListItem">
            <a property="item" typeof="WebPage" href="/projects/">
              <span property="name"><b>Projects</b></span>
            </a>
            <meta property="position" content="2" />
        </li>
      
        

        
          <li class="breadcrumb-item" property="itemListElement" typeof="ListItem">
            <span property="name">Benchmarking seL4</span>
            <meta property="position" content="3" /></li>
          
    </ol>
  </nav>
  <nav class="sel-version" aria-label="Current Versions">
    <ol class="list-unstyled">
      <li class="list-unstyled text-right" style="margin-left:auto; padding:0rem 0rem;">
        Current versions:</li>
      <li class="list-unstyled text-right">
      <a href="/releases/sel4/13.0.0"><b>seL4-13.0.0</b></a></li>
      <li class="list-unstyled text-right">
      <a href="/releases/microkit/1.4.1"><b>microkit-1.4.1</b></a></li>
      <li class="list-unstyled text-right">
      <a href="/releases/camkes/camkes-3.11.0"><b>camkes-3.11.0</b></a></li>
      <li class="list-unstyled text-right">
      <a href="/releases/capdl/0.3.0"><b>capDL-0.3.0</b></a></li>
      </ol>
  </nav>
  <div class='clear'></div>
</div>


</header>

    <main>
      <div class="row">
  <div class="hidden-xs col-sm-4 col-md-3 col-lg-2">
    


<div class="sidebar">















    <ul class="nav nav-sidebar">
  
    
    

    
        <li class="">
            <a class="" href="/projects/sel4/">seL4</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/l4v/">L4.verified</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/camkes/">CAmkES</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/capdl/">CapDL</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/buildsystem/">seL4 Buildsystem</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/elfloader/">Elfloader</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/user_libs/">user_libs</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/sel4runtime/">The seL4 run-time</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/sel4bench/">sel4bench</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/sel4test/">seL4Test</a>
        </li>
  
    
    

    
        <li class="active">
            <a class="" href="/projects/sel4-tutorials/">seL4 tutorials</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/sel4webserver/">seL4webserver</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/camkes-vm/">camkes-vm</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/virtualization/">Virtualization</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/sel4_tools/">seL4_tools</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/dockerfiles/">Dockerfiles</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/docsite/">seL4 Documentation website</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/microkit/">Microkit</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/hardware_hacks/">Hardware Hacks</a>
        </li>
  
    
    

    
        <li class="">
            <a class="" href="/projects/rust/">Rust</a>
        </li>
  
    </ul>


</div>

  </div>
  <div class="content col-sm-8 col-md-6 col-lg-7 main">
    <h1 id="benchmarking-sel4">Benchmarking seL4</h1>

<h2 id="benchmarking-project">Benchmarking project</h2>
<p>There is a set of microbenchmarks for seL4
available, see the
<a href="https://github.com/seL4/sel4bench-manifest">sel4bench-manifest</a>.</p>

<h1 id="benchmarking-tools">Benchmarking Tools</h1>

<p>We have developed a set of tools which can be used to analyse kernel and
workload performance.</p>

<h2 id="cpu-utilisation">CPU Utilisation</h2>
<p>Threads (including the idle thread) and the overall system time (in cycles) can
be tracked by enabling the “track CPU utilisation feature”. This feature can be
enabled by setting the CMake configuration option <code class="language-plaintext highlighter-rouge">KernelConfiguration</code> to
<code class="language-plaintext highlighter-rouge">track_utilisation</code>.</p>

<p>By enabling CPU utilisation tracking, the kernel is instrumented with
some variables and functions to log the utilisation time for each thread
(thus TCBs have additional variables for this purpose); the in-kernel
buffer is not used. During each context switch, the kernel adds how long
this heir thread has run before being switched, and resets the start
time of the next thread.</p>

<h3 id="how-to-use">How to use</h3>

<p>After enabling this feature, some few system calls can be used to start,
stop, and retrieve data.</p>

<p><strong>seL4_BenchmarkResetLog()</strong> This system call resets global counters
(since the previous call to the same function) and idleThread counters
that hold utilisation values, and starts CPU utilisation tracking.</p>

<p><strong>seL4_BenchmarkResetThreadUtilisation(seL4_CPtr thread_cptr)</strong>
resets the utilisation counters for the requested thread. It’s the
resposibility of the user to reset the thread’s counters using this
system call before calling seL4_BenchmarkResetLog(), especially if
seL4_BenchmarkResetLog() is called multiple times to track the same
thread(s).</p>

<p><strong>seL4_BenchmarkFinalizeLog()</strong> Stops the CPU tracking feature but
doesn’t reset the counters. Calling this system call without a previous
seL4_BenchmarkResetLog() call has no effect.</p>

<p><strong>seL4_BenchmarkGetThreadUtilisation(seL4_CPtr thread_cptr)</strong> Gets
the utilisation time of the thread that <strong>thread_cptr</strong> capability
points to between calls to seL4_BenchmarkResetLog() and
seL4_BenchmarkFinalizeLog(). The utilisation time is dumped to the
IPCBuffer (first 64-bit word) of the calling thread into a fixed
position. Additionally idle thread and overall CPU utilisation times are
dumped to subsequent 64-bit words in the IPCBuffer.</p>

<p>Example code of using this feature:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sel4/benchmark_utilisation_types.h&gt;</span><span class="cp">
</span>
<span class="kt">uint64_t</span> <span class="o">*</span><span class="n">ipcbuffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">seL4_GetIPCBuffer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="n">seL4_BenchmarkResetThreadUtilisation</span><span class="p">(</span><span class="n">seL4_CapInitThreadTCB</span><span class="p">);</span>

<span class="n">seL4_BenchmarkResetLog</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">seL4_BenchmarkFinalizeLog</span><span class="p">();</span>

<span class="n">seL4_BenchmarkGetThreadUtilisation</span><span class="p">(</span><span class="n">seL4_CapInitThreadTCB</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Init thread utilisation = %llun"</span><span class="p">,</span> <span class="n">ipcbuffer</span><span class="p">[</span><span class="n">BENCHMARK_TCB_UTILISATION</span><span class="p">]);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Idle thread utilisation = %llun"</span><span class="p">,</span> <span class="n">ipcbuffer</span><span class="p">[</span><span class="n">BENCHMARK_IDLE_UTILISATION</span><span class="p">]);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Overall utilisation = %llun"</span><span class="p">,</span> <span class="n">ipcbuffer</span><span class="p">[</span><span class="n">BENCHMARK_TOTAL_UTILISATION</span><span class="p">]);</span>
</code></pre></div></div>

<h2 id="in-kernel-log-buffer">In kernel log-buffer</h2>

<p>An in-kernel log buffer can be provided by the user when the <code class="language-plaintext highlighter-rouge">KernelBenchmarks</code>
CMake config option is set to <code class="language-plaintext highlighter-rouge">track_kernel_entries</code> or <code class="language-plaintext highlighter-rouge">tracepoints</code> with the
system call <code class="language-plaintext highlighter-rouge">seL4_BenchmarkSetLogBuffer</code>. Users must provide a large frame
capability for the kernel to use as a log buffer. This is mapped write-through
to avoid impacting the caches, assuming that the kernel only writes to the log
buffer and doesn’t read to it during benchmarking. Once a benchmark is
complete, data can be read out at user level.</p>

<p>We provide several benchmarking tools that use the log buffer (trace
points and kernel entry tracking).</p>

<h2 id="tracepoints">Tracepoints</h2>
<p>We allow the user to specify tracepoints in the kernel
to track the time between points.</p>

<h3 id="how-to-use-1">How to use</h3>
<p>Set the <code class="language-plaintext highlighter-rouge">KernelBenchmarks</code> CMake config option to <code class="language-plaintext highlighter-rouge">tracepoints</code>. Then set the
<code class="language-plaintext highlighter-rouge">KernelMaxNumTracePoints</code> CMake config option to a non-zero value.</p>

<p>Wrap the regions you wish to time with TRACE_POINT_START(i) and
TRACE_POINT_STOP(i) where i is an integer from 0 to 1 less than the
value of “Maximum number of tracepoints”.</p>

<p>The number of cycles consumed between a TRACE_POINT_START and
TRACE_POINT_STOP will be stored in an in-kernel log. Entries of this
log consist of a key (the argument to TRACE_POINT_START and
TRACE_POINT_STOP) and a value (the number of cycles counted between
TRACE_POINT_START an TRACE_POINT_STOP).</p>

<p>Functionality for extracting and processing entries from this buffer is
provided in libsel4bench (<a href="https://github.com/seL4/libsel4bench">https://github.com/seL4/libsel4bench</a>).</p>

<p>An example of this feature in use can be found in the irq path benchmark
in the sel4bench app(<a href="https://github.com/seL4/libsel4bench">https://github.com/seL4/libsel4bench</a>).</p>

<h3 id="tracepoint-overhead">Tracepoint Overhead</h3>

<h4 id="measuring-overhead">Measuring Overhead</h4>
<p>Using tracepoints adds a small amount of overhead to the kernel. To measure
this overhead, use a pair of nested tracepoints:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>
<p>The outer tracepoints will measure the time taken to start and stop
the inner tracepoints. The cycle count recorded by the outer tracepoints
will be slightly skewed, as starting and stopping itself (the outer
tracepoints) takes some number of cycles. To determine how many, we look
to the inner tracepoints. Since this pair is empty, it will record the
number of cycles added to a result by the tracepoint instrumentation.
Thus, to compute the total overhead of starting and stopping a
tracepoint, subtract the values measured by the inner tracepoints from
those measured by the outer tracepoints.</p>

<h4 id="results">Results</h4>
<p>All results are in cycles. Results were obtained using
the method described above. The total overhead is the number of cycles
added to execution per tracepoint start/stop pair (inner pair result
subtracted from outer pair result). The effective overhead is the number
of cycles added to a measurement by the tracepoint instrumentation
(inner pair result).</p>

<ul>
  <li>Total Overhead</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Machine</th>
      <th># Samples</th>
      <th>Min</th>
      <th>Max</th>
      <th>Mean</th>
      <th>Variance</th>
      <th>Std Dev</th>
      <th>Std Dev %</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sabre</td>
      <td>740</td>
      <td>18</td>
      <td>18</td>
      <td>18</td>
      <td>0</td>
      <td>0</td>
      <td>0%</td>
    </tr>
    <tr>
      <td>Haswell2</td>
      <td>740</td>
      <td>532</td>
      <td>852</td>
      <td>550.33</td>
      <td>295.16</td>
      <td>17.19</td>
      <td>3%</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Effective overhead</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Machine</th>
      <th># Samples</th>
      <th>Min</th>
      <th>Max</th>
      <th>Mean</th>
      <th>Variance</th>
      <th>Std Dev</th>
      <th>Std Dev %</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sabre</td>
      <td>740</td>
      <td>4</td>
      <td>4</td>
      <td>4</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Haswell2</td>
      <td>740</td>
      <td>208</td>
      <td>212</td>
      <td>208.69</td>
      <td>2.75</td>
      <td>1.66</td>
      <td>1%</td>
    </tr>
  </tbody>
</table>

<h3 id="advanced-use">Advanced Use</h3>
<h4 id="conditional-logging">Conditional Logging</h4>
<p>A log is stored when
TRACE_POINT_STOP(i) is called, only if a corresponding
TRACE_POINT_START(i) was called since the last call to
TRACE_POINT_STOP(i) or system boot. This allows for counting cycles of
a particular path through some region of code. Here are some examples:</p>

<p>The cycles consumed by functions f and g is logged with the key 0, only
when the condition c is true:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">f</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">();</span>
    <span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The cycles consumed by functions f and g is
logged with the key 1, only when the condition c is true:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">();</span>
    <span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">g</span><span class="p">();</span>
<span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>These two techniques can be combined to
record cycle counts only when a particular path between 2 points is
followed. In the following example, cycles consumed by functions f, g
and h is logged, only when the condition c is true. Cycle counts are
stored with 2 keys (2 and 3) which can be combined after extracting the
data to user level.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">f</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">h</span><span class="p">();</span>
    <span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">g</span><span class="p">();</span>
<span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="interleavingnesting">Interleaving/Nesting</h4>
<p>It’s possible to interleave tracepoints:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>and to nest tracepoints:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">TRACE_POINT_START</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">TRACE_POINT_STOP</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>
<p>When interleaving or nesting tracepoints, be
sure to account for the overhead that will be introduced.</p>

<h2 id="kernel-entry-tracking">Kernel entry tracking</h2>
<p>Kernel entries can be tracked, registering info about interrupts, syscall,
timestamp, invocations and capability types. The number of kernel entries is
restricted by the log buffer size. The kernel provides a reserved area within
its address space to map the log buffer. It’s the responsibility of the user to
allocate a user-level log buffer (currently can be only of seL4_LargePageBits
size) and pass it to the kernel to use before doing any operations that involve
the log buffer, otherwise an error will be triggered having incorrect
user-level log buffer. To enable this feature, set the <code class="language-plaintext highlighter-rouge">KernelBenchmarks</code> CMake
config option to <code class="language-plaintext highlighter-rouge">track_kernel_entries</code>.</p>

<p>An example how to create a user-level log buffer (using sel4 libraries)
and tell the kernel about it is as follows:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef CONFIG_BENCHMARK_TRACK_KERNEL_ENTRIES
</span>
<span class="cp">#include</span> <span class="cpf">&lt;sel4/benchmark_track_types.h&gt;</span><span class="cp">
</span>
  <span class="cm">/* Create large page to use for benchmarking and give to kernel */</span>
  <span class="kt">void</span><span class="o">*</span><span class="n">log_buffer</span> <span class="o">=</span> <span class="n">vspace_new_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">.</span><span class="n">vspace</span><span class="p">,</span> <span class="n">seL4_AllRights</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seL4_LargePageBits</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">log_buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ZF_LOGF</span><span class="p">(</span><span class="s">"Could not map log_buffer page"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">seL4_CPtr</span> <span class="n">buffer_cap</span> <span class="o">=</span> <span class="n">vspace_get_cap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">.</span><span class="n">vspace</span><span class="p">,</span> <span class="n">log_buffer</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buffer_cap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ZF_LOGF</span><span class="p">(</span><span class="s">"Could not get cap for log buffer"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">res_buf</span> <span class="o">=</span> <span class="n">seL4_BenchmarkSetLogBuffer</span><span class="p">(</span><span class="n">buffer_cap</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ZF_LOGF</span><span class="p">(</span><span class="s">"Could not set log buffer"</span><span class="p">);</span>
  <span class="p">}</span>

<span class="cp">#endif CONFIG_BENCHMARK_TRACK_KERNEL_ENTRIES
</span></code></pre></div></div>

<p>seL4_BenchmarkResetLog() can be used then to reset the log buffer index
and start tracking. To stop tracking, call seL4_BenchmarkFinalizeLog()
which returns the log buffer index. Note, if the buffer is
full/saturated, it will return the last entry index of the log buffer.
Finally, the log buffer can be analyzed to extract desired info. For
reference, there are utility functions to extract such information in
<a href="https://github.com/seL4/seL4_libs/blob/master/libsel4utils/include/sel4utils/benchmark_track.h">sel4utils/benchmark_track.h</a>.</p>

<h3 id="hints">Hints</h3>
<p>If you want only entry or exit times instead of function
call durations, modify line 56 of kernel/include/benchmark.h. This might
be useful if you wish to time hardware events. For example, should you
wish to time how long it takes for hardware to generate a fault to the
kernel, perhaps record the cycle counter before causing the fault in
userspace, then store the <code class="language-plaintext highlighter-rouge">ksEntry</code> as soon as you enter somewhere
relevant in the kernel, and then compare the difference of these two
once you return to userspace, by reading out the value and taking the
difference.</p>

  </div>







  
    
<div class="sidebar-toc hidden-xs hidden-sm col-md-3 col-lg-3">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#benchmarking-project">Benchmarking project</a></li>
<li class="toc-entry toc-h2"><a href="#cpu-utilisation">CPU Utilisation</a>
<ul>
<li class="toc-entry toc-h3"><a href="#how-to-use">How to use</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#in-kernel-log-buffer">In kernel log-buffer</a></li>
<li class="toc-entry toc-h2"><a href="#tracepoints">Tracepoints</a>
<ul>
<li class="toc-entry toc-h3"><a href="#how-to-use-1">How to use</a></li>
<li class="toc-entry toc-h3"><a href="#tracepoint-overhead">Tracepoint Overhead</a>
<ul>
<li class="toc-entry toc-h4"><a href="#measuring-overhead">Measuring Overhead</a></li>
<li class="toc-entry toc-h4"><a href="#results">Results</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#advanced-use">Advanced Use</a>
<ul>
<li class="toc-entry toc-h4"><a href="#conditional-logging">Conditional Logging</a></li>
<li class="toc-entry toc-h4"><a href="#interleavingnesting">Interleaving/Nesting</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#kernel-entry-tracking">Kernel entry tracking</a>
<ul>
<li class="toc-entry toc-h3"><a href="#hints">Hints</a></li>
</ul>
</li>
</ul>
</div>

  
  
<div class="sidebar-toc hidden-xs hidden-sm col-md-3 col-lg-3">
  
    <ul class="section-nav">
    	<h2> seL4 tutorials </h2> 
        <li>
          
          <a style="" class="" href="/projects/sel4-tutorials/">
            Documentation homepage
          </a>
        </li>

















    
        <h3>Repositories</h3>
    
        <li>
          <a class="" href="https://github.com/sel4proj/sel4-tutorials">
            sel4-tutorials
          </a>
        </li>

    
        <li>
          <a class="" href="https://github.com/sel4proj/sel4-tutorials-manifest">
            sel4-tutorials-manifest
          </a>
        </li>









  







    
        <h3>Recent Updates</h3>
    
        <li>
          <a style="" href="/updates/sel4-tutorials/camkes-3.8.x.html">
            camkes-3.8.x-compatible
          </a>
        </li>

    </ul>

</div>


</div>

    </main>
    


<footer class="site-footer">

  <h2 class="footer-heading">seL4 docs</h2>

  <div class="footer-col-wrapper">

    <div class="col-md-2">
      



<ul class="social-media-list">
  <li><a href="https://github.com/sel4"><i class="fab fa-github"></i> <span class="username">sel4</span></a></li><li><a href="https://github.com/sel4proj"><i class="fab fa-github"></i> <span class="username">sel4proj</span></a></li>
</ul>

    </div>

    <div class="col-md-8">
      <ul class="list-unstyled">
        <li>
          This site is for displaying seL4 related documentation.  Pull requests are welcome.
        </li>
        
          <li>
            Site last updated: Fri Feb 7 10:17:38 2025 +1100 ee78c8857c
          </li>
          <li>
                Page last updated: Mon Nov 30 09:25:37 2020 +1100 977ed44f17
          </li>
        
      </ul>
    </div>
    <div class="col-md-2">
<a href="https://github.com/seL4/docs/blob/master/projects/sel4-tutorials/benchmarking-guide.md">View page on GitHub</a>
      <br />
      <a href="https://github.com/seL4/docs/edit/master/projects/sel4-tutorials/benchmarking-guide.md">Edit page on GitHub</a>
      <br />
      <a href="/sitemap">Sitemap</a>
    </div>

  </div>

</footer>

  </body>
</html>
