<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Rust in seL4 Userspace</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/sel4-rust-tutorial.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Using Rust in seL4 Userspace</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/seL4/seL4-rust-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="tutorial-using-rust-in-sel4-userspace"><a class="header" href="#tutorial-using-rust-in-sel4-userspace">Tutorial: Using Rust in seL4 Userspace</a></h1>
<p>seL4 has official support for Rust in userspace, funded by the seL4 Foundation:</p>
<p><a href="https://github.com/seL4/rust-sel4">https://github.com/seL4/rust-sel4</a></p>
<p>The exports of this project covered in this tutorial are:</p>
<ul>
<li>Rust bindings for the seL4 API</li>
<li>A runtime for root tasks</li>
<li>Rust bindings for the seL4 Microkit API</li>
<li>A runtime for <a href="https://github.com/seL4/microkit">seL4 Microkit</a> protection domains</li>
<li>Custom rustc <a href="https://docs.rust-embedded.org/embedonomicon/custom-target.html">target specifications</a> for seL4 userspace</li>
</ul>
<p><a href="root-task/">Part I</a> covers the Rust bindings for the seL4 API and the runtime for root tasks.
Familiarity with the seL4 API isn't necessarily assumed or required, but this text doesn't introduce its elements in as much detail as the <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf">seL4 Manual</a>.</p>
<p><a href="microkit/">Part II</a> is much shorter, and covers the Rust language runtime for seL4 Microkit protection domains and implementation of the Microkit API.
This part does assume that the reader is familiar with the basics of the Microkit framework and API, or is using a companion resource to learn about the Microkit in parallel.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This tutorial is presented as a linear series of patches to <a href="https://github.com/seL4/seL4-rust-tutorial-code">https://github.com/seL4/seL4-rust-tutorial-code</a>, starting at commit <code>d27fd3f560e4</code>, and ending with commit <code>b886a72fdfec</code>.
Each patch, or step, as we shall call them, is an instructive modification to a code example.
You are encouraged (but by no means required) to attempt those marked as exercises in this text on your own.
Note that while most step patches include tests, the reader is not expected to write tests for exercises themselves.</p>
<p>Clone the repository and checkout the starting commit:</p>
<pre><code>git clone https://github.com/seL4/seL4-rust-tutorial-code
cd seL4-rust-tutorial-code
git checkout d27fd3f560e4
</code></pre>
<p>Observe the steps ahead:</p>
<pre><code>git log d27fd3f560e4..b886a72fdfec
</code></pre>
<p>Each step header contains two icons.
Clicking the clipboard copies the commit hash corresponding to the step to the clipboard.
The GitHub icon is a link to the commit on GitHub.</p>
<p>Use any Git workflow that works for you.
For example, you could cherry-pick the steps that are not marked as exercises after examining and understanding them, and then attempt the exercises on your own, using those step commits as hints when necessary.</p>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>We will work inside of a Docker container built with <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/docker/Dockerfile">docker/Dockerfile</a>.
This Dockerfile installs some build-time dependencies, and then builds seL4, <a href="https://github.com/seL4/microkit">seL4 Microkit</a>, and some additional programs and tools.</p>
<p>Build the image:</p>
<pre><code>make -C docker build
</code></pre>
<p>Run a container in the background:</p>
<pre><code>make -C docker run
</code></pre>
<p>Start a shell inside the container:</p>
<pre><code>make -C docker exec
</code></pre>
<p>The rest of this text assumes that you are in a shell inside the container.</p>
<h3 id="two-workspaces"><a class="header" href="#two-workspaces">Two Workspaces</a></h3>
<p>To simplify our Cargo invocations, this repository's Rust code has been divided between two distinct workspaces: <a href="https://github.com/seL4/seL4-rust-tutorial-code/tree/d27fd3f560e48920d004dd97900ef49449d89441/workspaces/root-task">workspaces/root-task</a> and <a href="https://github.com/seL4/seL4-rust-tutorial-code/tree/d27fd3f560e48920d004dd97900ef49449d89441/workspaces/microkit">workspaces/microkit</a>.
Both are subject to the top-level <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/.cargo/config.toml">.cargo/config.toml</a>, whereas <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/workspaces/root-task/.cargo/config.toml">workspaces/root-task/.cargo/config.toml</a> and <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/workspaces/microkit/.cargo/config.toml">workspaces/microkit/.cargo/config.toml</a> each apply to only one.
These workspace-specific <code>config.toml</code> files demonstrate all that is required to configure the crates in the <a href="https://github.com/seL4/rust-sel4">rust-sel4</a> project:</p>
<ul>
<li>An environment variable pointing at <code>libsel4</code> (which includes the kernel configuration).
See <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/index.html#building">the relevant crate docs</a> for information on this environment variable.</li>
<li>A reference to a custom rustc <a href="https://docs.rust-embedded.org/embedonomicon/custom-target.html">target specification</a> (the location of the target specification is given at <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/.cargo/config.toml#L8">.cargo/config.toml:8</a>, which refers to <a href="https://github.com/seL4/seL4-rust-tutorial-code/tree/d27fd3f560e48920d004dd97900ef49449d89441/target-specs">target-specs</a>).</li>
</ul>
<h3 id="vscode--dev-containers"><a class="header" href="#vscode--dev-containers">VSCode + Dev Containers</a></h3>
<p>If you want help from <a href="https://rust-analyzer.github.io/">rust-analyzer</a>, the Rust Language Server, you can use <a href="https://code.visualstudio.com/docs/devcontainers/tutorial">VSCode with the Dev Containers extension</a>.
This will enable you to run VSCode inside of the container you just built, which contains the seL4 build artifacts that rust-analyzer will require to analyzer your code.</p>
<p>This repository provides a separate Dev Container configuration for each workspace:</p>
<ul>
<li><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/.devcontainer/root-task/devcontainer.json">.devcontainer/root-task/devcontainer.json</a></li>
<li><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/.devcontainer/microkit/devcontainer.json">.devcontainer/microkit/devcontainer.json</a></li>
</ul>
<p>To work in a particular workspace, open this repository in VSCode, run <code>&gt; Dev Containers: Reopen in Container</code>, and select the corresponding configuration.
You should now be able to use the rust-analyzer VSCode extension normally for the code in the selected workspace.</p>
<h3 id="rustdoc"><a class="header" href="#rustdoc">Rustdoc</a></h3>
<p>Rustdoc for the rust-sel4 project is hosted here:</p>
<p><a href="https://sel4.github.io/rust-sel4/">https://sel4.github.io/rust-sel4/</a></p>
<p>However, for the sake of consistency, rustdoc for the particular configurations studied in this text are hosted here too.
There is one set of rustdoc for each of the two workspace configurations mentioned in <a href="setup.html#two-workspaces">Two Workspaces</a>.
Rustdoc does not generate an index page, but you can navigate across crates within a workspace configuration using the sidebar present on top-level rustdoc page for any module.</p>
<ul>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/index.html">Rustdoc for Part I</a></li>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4/index.html">Rustdoc for Part II</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="the-root-task"><a class="header" href="#the-root-task">The Root Task</a></h1>
<p>After initializing itself, the seL4 kernel passes control to a userspace program called the root task, whose image is provided to the kernel at boot-time.
The root task's <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#chapter.3">capability space</a> contains capabilities for all memory and boot-time objects.
That is to say, the root task spawns with the maximum privilege that a userspace program can have.
The kernel provides the root task with a map of its initial capability space in the form of the <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.9.2">BootInfo frame</a>.
You can read more about the root task's environment in <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.9.1">seL4 Reference Manual § 9.1</a>.</p>
<p>Part I of this tutorial will focus on writing from-scratch root tasks in Rust.
Some of the code in Part I will be quite low-level, interacting with the language runtime, the linker, and some of the finer details related to bootstrapping an seL4-based system.
The only seL4-related crates we will be using are the language runtime and bindings for the seL4 API.
Unlike situations where higher-level seL4-related libraries (such as <a href="https://github.com/seL4/seL4_libs">seL4_libs</a>) are used, we will be allocating objects and manage virtual address spaces from scratch.</p>
<p>At boot time, the seL4 kernel and root task are loaded into memory by a kind of bootloader stub referred to as a seL4 kernel loader.
For Part I, we will use the <a href="https://github.com/seL4/rust-sel4/tree/v1.0.0/crates/sel4-kernel-loader">kernel loader from the rust-sel4 project</a>.
We won't cover how it works or how to use it explicitly in this text.
It is built at <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/docker/Dockerfile#L94-L108">docker/Dockerfile:94:108</a>, and used at <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/d27fd3f560e48920d004dd97900ef49449d89441/mk/root-task.mk#L31-L36">mk/root-task.mk:31:36</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>Run the hello world example:</p>
<pre><code>cd workspaces/root-task/hello-world
make simulate
</code></pre>
<p>Press <code>ctrl-a x</code> to exit QEMU.</p>
<p>Here is its source:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/6a0418982760bc2e9c0fc6fe91cdc614757d0195/workspaces/root-task/hello-world/src/main.rs#L7-L17">hello-world/src/main.rs:7:17</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use sel4_root_task::root_task;

#[root_task]
fn main(_bootinfo: &amp;sel4::BootInfoPtr) -&gt; ! {
    sel4::debug_println!("Hello, World!");

    sel4::init_thread::suspend_self()
}
</code></pre>
</div>
</div>
<p>The Rust standard library is divided into three layers:</p>
<ul>
<li><a href="https://doc.rust-lang.org/core/"><code>core</code></a>: dependency-free foundation</li>
<li><a href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a>: implements heap-backed data structures, but requires a runtime that provides a heap allocator</li>
<li><a href="https://doc.rust-lang.org/std/"><code>std</code></a> includes <code>core</code> and <code>alloc</code>, and adds APIs that depend on OS services such as networking and filesystems</li>
</ul>
<p>The high-level <code>std</code> doesn't support the low-level seL4 root task target.
<a href="https://docs.rust-embedded.org/book/intro/no-std.html"><code>#![no_std]</code></a> declares that this crate does not depend on <code>std</code>, and prevents rustc from automatically importing it.</p>
<p>Our language runtime will handle the program's entrypoint differently than a typical Rust program.
<a href="https://doc.rust-lang.org/reference/crates-and-source-files.html#the-no_main-attribute"><code>#![no_main]</code></a> informs rustc of this fact.</p>
<p>The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/index.html"><code>sel4</code> crate</a> binds the seL4 API.
It is generated from source (<code>.xml</code>, <code>.bf</code>, and <code>.h</code>) in <code>libsel4</code>.
We will cover the contents of this crate in future chapters.</p>
<p>The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_root_task/index.html"><code>sel4_root_task</code> crate</a> implements a Rust language runtime for the root task environment.</p>
<p>The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_root_task/attr.root_task.html"><code>#[root_task]</code></a> attribute macro declares a function to be the root task's entrypoint.
The entrypoint function must have a signature of the form:</p>
<pre><code class="language-rust ignore">fn(&amp;sel4::BootInfoPtr) -&gt; T
where
    T: sel4_root_task::Termination</code></pre>
<p>(Rustdoc for <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.BootInfoPtr.html"><code>BootInfoPtr</code></a> and <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_root_task/trait.Termination.html"><code>Termination</code></a>)</p>
<p>The root task has no way to exit, so, to terminate cleanly, it must suspend its own thread.
<code>sel4::init_thread::suspend_self()</code> does exactly this.</p>
<h2 id="step-2a-exercise"><a class="header" href="#step-2a-exercise">Step 2.A (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('57db641a576be7b543c6d0655b0470b1c800d713')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/57db641a576be7b543c6d0655b0470b1c800d713"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> Cause a panic.</p>
<h2 id="step-2b-exercise"><a class="header" href="#step-2b-exercise">Step 2.B (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('e747327f84222e3d3d3643c1ecb7dc15199fc05e')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/e747327f84222e3d3d3643c1ecb7dc15199fc05e"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> Catch the panic using <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_root_task/panicking/fn.catch_unwind.html"><code>sel4_root_task::panicking::catch_unwind()</code></a>.</p>
<h2 id="step-2c-exercise"><a class="header" href="#step-2c-exercise">Step 2.C (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('eadf1d91c520decd24164de6e650345428eb6c4c')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/eadf1d91c520decd24164de6e650345428eb6c4c"> <i class="fa fa-github"></i> </a></a></h2>
<p>You can set a custom panic hook with <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_root_task/panicking/type.PanicHook.html"><code>sel4_root_task::panicking::PanicHook</code></a>.
The default hook just prints the panic's <code>ExternalPanicInfo</code>.</p>
<p><strong>Exercise:</strong> Set a custom panic hook.</p>
<h2 id="step-2d-exercise"><a class="header" href="#step-2d-exercise">Step 2.D (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('e47556acc781e682fcd69fb0e3bce9eda06c543b')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/e47556acc781e682fcd69fb0e3bce9eda06c543b"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> Cause a stack overflow.</p>
<h2 id="step-2e-exercise"><a class="header" href="#step-2e-exercise">Step 2.E (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('f0f50266033bae0848bfc04d99400611d7c9164b')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/f0f50266033bae0848bfc04d99400611d7c9164b"> <i class="fa fa-github"></i> </a></a></h2>
<p>The <code>#[root_task]</code> attribute macro accepts a named <code>stack_size</code> parameter, which can be any expression of type <code>usize</code> and whose value is interpreted as the root task's initial thread's stack size, in bytes.
For example:</p>
<pre><code class="language-rust ignore">#[root_task(stack_size = 13 * 37)]</code></pre>
<p>The default stack size is <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_root_task/constant.DEFAULT_STACK_SIZE.html"><code>sel4_root_task::DEFAULT_STACK_SIZE</code></a>.</p>
<p><strong>Exercise:</strong> Adjust the root task's initial thread's stack size to prevent the stack overflow you just caused.</p>
<h2 id="step-2f-exercise"><a class="header" href="#step-2f-exercise">Step 2.F (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('09bd92fb5dc403d66f660fc470fbb769a93cc9f6')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/09bd92fb5dc403d66f660fc470fbb769a93cc9f6"> <i class="fa fa-github"></i> </a></a></h2>
<p>By default, the <code>sel4_root_task</code> runtime does not include a heap.
Any attempt to use the <code>alloc</code> crate will result in a link-time failure.</p>
<p>The <code>#[root_task]</code> attribute macro accepts a <code>heap_size</code> parameter, which can be any expression of type <code>usize</code> and whose value is interpreted as the root task's heap size, in bytes.
Note that <code>heap_size</code> must come after <code>stack_size</code> in the case where both are present.
For example:</p>
<pre><code class="language-rust ignore">#[root_task(heap_size = 0xf00d)]</code></pre>
<p>or</p>
<pre><code class="language-rust ignore">#[root_task(stack_size = 13 * 37, heap_size = 0xf00d)]</code></pre>
<p><strong>Exercise:</strong> Add a heap and use it.</p>
<h2 id="step-2g"><a class="header" href="#step-2g">Step 2.G   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('321b5ac58e8d0f683ec97b51260fb652dc59af3d')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/321b5ac58e8d0f683ec97b51260fb652dc59af3d"> <i class="fa fa-github"></i> </a></a></h2>
<p>The <code>sel4_logging</code> crate builds on top of the <a href="https://docs.rs/log/latest/log/">log</a> crate to add utilities for initializing simple loggers in minimal environments, such as a seL4 root task.
This step demonstrates one way to initialize a logger using this crate:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/321b5ac58e8d0f683ec97b51260fb652dc59af3d/workspaces/root-task/hello-world/src/main.rs#L17-L20">hello-world/src/main.rs:17:20 after 2.G</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">static LOGGER: Logger = LoggerBuilder::const_default()
    .level_filter(LevelFilter::Info)
    .write(|s| sel4::debug_print!("{}", s))
    .build();
</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/321b5ac58e8d0f683ec97b51260fb652dc59af3d/workspaces/root-task/hello-world/src/main.rs#L41">hello-world/src/main.rs:41 after 2.G</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    LOGGER.set().unwrap();
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="allocating-kernel-objects"><a class="header" href="#allocating-kernel-objects">Allocating Kernel Objects</a></h1>
<p>Start by navigating to and running this chapter's example, which, so far, is empty.</p>
<pre><code>cd workspaces/root-task/kernel-objects
make simulate
</code></pre>
<p>Userspace operates the seL4 kernel by creating, managing, and accessing kernel objects via references called <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.2.1"><em>capabilites</em></a>.
See <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.2.3">seL4 Reference Manual § 2.3 (Kernel Objects)</a> for an outline of the core types of kernel objects.</p>
<p>In the context of seL4, a capability is a granular, unforgeable token of authority that references a kernel object and carries access rights that limit what the user of a cabability can do with the referenced kernel object.
In general, a system call in seL4 amounts to refering to a cabability and an action on the kernel object the cabability points to.
This is called <em>invoking a capability</em>.</p>
<!-- As elaborated in [seL4 Reference Manual § 2.3 (Kernel Objects)](https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.2.3), the core kernel object types are:
- CNode: a table containing capabilites, used to construct so-called capability spaces, which are assigned to threads. When making a syscall, a thread refers to capabilities in its capability space to in turn refer to kernel objects.
- Thread control block: the state associated with a thread's execution context. Used to control a thread.
- Scheduling context (only relevent to certain kernel configurations, not covered here): represents access to a CPU, used for scheduling.
- Endpoint: synchronous IPC endpoint, for message-passing between threads.
- Reply object (only relevent to certain kernel configurations, not covered here): tracks scheduling information accross IPC endpoint calls.
- Notification object: asynchronous signalling mechanism. -->
<p>Just as each thread is associated with a virtual address space which the hardware uses to translate virtual memory addresses into locations in physical memory, each seL4 thread is also assocated with a <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#chapter.3">capability space</a> (<em>CSpace</em>) which the kernel uses to translate so-called <em>capability pointers</em> (<em>CPointers</em> or <em>CPtrs</em>) into locations (slots) in the kernel's capability tables called <em>CNodes</em>.</p>
<p>The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.CPtr.html"><code>sel4::CPtr</code></a> type is a wrapper around a machine word.
The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.Cap.html"><code>sel4::Cap&lt;T&gt;</code></a> type wraps a <code>CPtr</code> associated with the current thread's CSpace, and thus points to a particular capability slot within the kernel.
It is paramterized by a capability type <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/trait.CapType.html"><code>T: sel4::CapType</code></a>, representing the type of capability in that slot.
It is up to the crate user to ensure that <code>Cap</code>'s are valid and well-typed in the current thread.</p>
<p>The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/index.html"><code>sel4::cap</code></a> module contains aliases of the form <code>sel4::Cap&lt;sel4::cap_type::*&gt;</code>.</p>
<p>Depending on the <code>Cap</code>'s type <code>T</code>, a <code>Cap</code> has a number of methods available, which correspond to invocations for that capability type.
For example, <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.Cap.html#method.tcb_resume"><code>sel4::Cap::tcb_resume()</code></a> is available when <code>T</code> is <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap_type/struct.Tcb.html"><code>sel4::cap_type::Tcb</code></a>.</p>
<h2 id="step-3a"><a class="header" href="#step-3a">Step 3.A   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('4e6e91719a3c19a37fecbeff55d0d28b15eebaf3')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/4e6e91719a3c19a37fecbeff55d0d28b15eebaf3"> <i class="fa fa-github"></i> </a></a></h2>
<p>As elaborated in <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.2.4">seL4 Reference Manual § 2.4 (Kernel Memory Allocation)</a>, userspace is responsible for managing the memory associated with kernel objects.
<em>Untyped memory</em> is the name of the object type for free memory.
At boot time, the root task is granted untyped memory capabilities for all of the system's memory, except for the memory used for the kernel and the root task's own resources.</p>
<p>Print the untyped memory described by the <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.9.2">BootInfo frame</a>:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/4e6e91719a3c19a37fecbeff55d0d28b15eebaf3/workspaces/root-task/kernel-objects/src/main.rs#L14-L22">workspaces/root-task/kernel-objects/src/main.rs:14:22 after 3.A</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    sel4::debug_println!("untyped:");
    for ut_desc in bootinfo.untyped_list() {
        sel4::debug_println!(
            "    paddr: {:#016x?}, size bits: {:02?}, is device: {:?}",
            ut_desc.paddr(),
            ut_desc.size_bits(),
            ut_desc.is_device()
        );
    }
</code></pre>
</div>
</div>
<p>Sample output:</p>
<pre><code>untyped:
    paddr: 0x00000000000000, size bits: 27, is device: true
    paddr: 0x00000008001000, size bits: 12, is device: true
    paddr: 0x00000008002000, size bits: 13, is device: true
    paddr: 0x00000008004000, size bits: 14, is device: true
    paddr: 0x00000008008000, size bits: 15, is device: true
    paddr: 0x00000008011000, size bits: 12, is device: true
    paddr: 0x00000008012000, size bits: 13, is device: true
    ...
</code></pre>
<p><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.UntypedDesc.html#method.size_bits"><code>sel4::UntypedDesc::size_bits()</code></a> returns the log base 2 of the size of the region of memory described by the descriptor.</p>
<p><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.UntypedDesc.html#method.is_device"><code>sel4::UntypedDesc::is_device()</code></a> returns whether the region is device memory or kernel memory.
Device memory can only be used for creating frames, whereas kernel memory has no such restrictions.</p>
<h2 id="step-3b"><a class="header" href="#step-3b">Step 3.B   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('be68b6a66ed494d58f7da13c23abf247c06fea6d')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/be68b6a66ed494d58f7da13c23abf247c06fea6d"> <i class="fa fa-github"></i> </a></a></h2>
<p>Add a function that finds the largest untyped region passed to the root task:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/be68b6a66ed494d58f7da13c23abf247c06fea6d/workspaces/root-task/kernel-objects/src/main.rs#L32-L42">workspaces/root-task/kernel-objects/src/main.rs:32:42 after 3.B</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn find_largest_kernel_untyped(bootinfo: &amp;sel4::BootInfo) -&gt; sel4::cap::Untyped {
    let (ut_ix, _desc) = bootinfo
        .untyped_list()
        .iter()
        .enumerate()
        .filter(|(_i, desc)| !desc.is_device())
        .max_by_key(|(_i, desc)| desc.size_bits())
        .unwrap();

    bootinfo.untyped().index(ut_ix).cap()
}
</code></pre>
</div>
</div>
<p>The expression <code>bootinfo.untyped().index(ut_ix).cap()</code> indexes into <code>bootinfo.untyped(): SlotRegion&lt;Untyped&gt;</code> to retrieve a <code>Slot&lt;Untyped&gt;</code>, which can be turned into a <code>Cap&lt;Untyped&gt; (= cap::Untyped)</code>.</p>
<h2 id="step-3c"><a class="header" href="#step-3c">Step 3.C   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('872f1a25a27afb8b68a98c270fec80c64a1e20e4')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/872f1a25a27afb8b68a98c270fec80c64a1e20e4"> <i class="fa fa-github"></i> </a></a></h2>
<p>In this step, we will allocate a <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#chapter.5">Notification</a> object.</p>
<p>We already know how to refer to a capability in the current thread's CSpace: a CPtr.
However, some capability invocations allow us to refer to a capability slot in any CSpace whose root CNode is present in the current thread's CSpace.
In these cases, we must provide:</p>
<ul>
<li>A CPtr, interpreted in the context of the current thread's CSpace, which points to the target CSpace's root CNode</li>
<li>A CPtr, interpreted in the context of the target CSpace, which points to the target capability slot</li>
<li>A depth, which is the number of bits of the second CPtr to interpret. This allows for the second CPtr to point to a CNode. Why this is necessary is outside the scope of this tutorial, but you can read about it in <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.2.4">seL4 Reference Manual § 2.4 (CSpace Addressing)</a>.</li>
</ul>
<p>Consider, for example, the <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsubsection.10.3.1.4"><code>seL4_CNode_Mint</code></a> capability invocation.
<code>dest_*</code> and <code>src_*</code> are both capability slots addressed in this way.</p>
<p>This more flexible method of capability slot addressing is encapsulated in the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.AbsoluteCPtr.html"><code>sel4::AbsoluteCPtr</code></a> type.</p>
<p>The <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsubsection.10.3.9.1"><code>seL4_Untyped_Retype</code></a> method is used for allocating new objects from an untyped object.
The <code>_service</code> parameter is the address of the untyped object as a normal CPtr.
<code>root</code>, <code>node_index</code>, and <code>node_depth</code> address, in the more flexible way outlined above, the destination CNode into which capabilities for the new objects will be inserted.
<code>node_offset</code> and <code>num_objects</code> specify a range of slots within the selected CNode for the new capabilites (and, simultaneously, the number of new objects that will be created).</p>
<p><code>type</code> and <code>size_bits</code> specify the shape of the new object(s)
Note that <code>size_bits</code> is relevant for only certain object types (see <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsection.2.4.2">seL4 Reference Manual § 2.4.2 (Summary of Object Sizes)</a> for more information).
This shape information is encapsulated in the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/enum.ObjectBlueprint.html"><code>sel4::ObjectBlueprint</code></a> type.</p>
<p>Multiple kernel objects can be allocated from a single unytped object.
For each untyped object, the kernel maintains a watermark which tracks how much of the untyped object has been used up for object allocation.
<code>seL4_Untyped_Retype</code> aligns the watermark to the desired object type's size, and then advances it according to the object type size and number of objects.
This process is detailed in the fourth paragraph of <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsection.2.4.1">seL4 Reference Manual § 2.4.1 (Reusing Memory)</a>.</p>
<p>Let us now work towards calling <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Untyped.html#method.untyped_retype"><code>sel4::cap::Untyped::untyped_retype()</code></a> on our previously acquired <code>largest_kernel_ut</code>.
We wish to allocate one notification object and insert a capability for it into a free slot in the current thread's own CSpace.
More precisely, we need a <code>sel4::AbsoluteCPtr</code> for the current thread's own CSpace's root CNode, and an index into that CNode for a free slot.</p>
<p>The CPtr for the initial thread's own CSpace root is a constant:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/872f1a25a27afb8b68a98c270fec80c64a1e20e4/workspaces/root-task/kernel-objects/src/main.rs#L27-L27">workspaces/root-task/kernel-objects/src/main.rs:27:27 after 3.C</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    let cnode = sel4::init_thread::slot::CNODE.cap();
</code></pre>
</div>
</div>
<p><code>bootinfo</code> can tell us about a range of empty slots in this CSpace.
We can leverage the fact that Rust's <code>Range&lt;T&gt;</code> type is an iterator for certain <code>T</code> to allocate slots in an ergonomic way:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/872f1a25a27afb8b68a98c270fec80c64a1e20e4/workspaces/root-task/kernel-objects/src/main.rs#L29-L33">workspaces/root-task/kernel-objects/src/main.rs:29:33 after 3.C</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    let mut empty_slots = bootinfo
        .empty()
        .range()
        .map(sel4::init_thread::Slot::from_index);
    let notification_slot = empty_slots.next().unwrap();
</code></pre>
</div>
</div>
<p>The {{#rustdoc_link root-task sel4/cap/type.CNode.html#method.absolute_cptr_for_self<code>sel4::cap::CNode::absolute_cptr_for_self()</code>}}  method elaborates a <code>sel4::cap::Cnode</code> into a <code>sel4::AbsoluteCPtr</code>.
Interestingly, there are two ways to do this, but the current implementation is just to use a depth of zero.</p>
<p>Now we can invoke our untyped capability to allocate a notification object:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/872f1a25a27afb8b68a98c270fec80c64a1e20e4/workspaces/root-task/kernel-objects/src/main.rs#L36-L43">workspaces/root-task/kernel-objects/src/main.rs:36:43 after 3.C</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    largest_kernel_ut
        .untyped_retype(
            &amp;sel4::ObjectBlueprint::Notification,
            &amp;cnode.absolute_cptr_for_self(),
            notification_slot.index(),
            1,
        )
        .unwrap();
</code></pre>
</div>
</div>
<p>Now that we know that <code>notification_slot</code> contains a notification capability, we can cast it and get a <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Notification.html"><code>sel4::cap::Notification</code></a>:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/872f1a25a27afb8b68a98c270fec80c64a1e20e4/workspaces/root-task/kernel-objects/src/main.rs#L45-L47">workspaces/root-task/kernel-objects/src/main.rs:45:47 after 3.C</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    let notification = notification_slot
        .downcast::&lt;sel4::cap_type::Notification&gt;()
        .cap();
</code></pre>
</div>
</div>
<h2 id="step-3d-exercise"><a class="header" href="#step-3d-exercise">Step 3.D (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('681fb5c21086ca3da70db911144212f0bd36fa26')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/681fb5c21086ca3da70db911144212f0bd36fa26"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong>: Use <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Notification.html#method.signal"><code>sel4::cap::Notification::signal()</code></a> and <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Notification.html#method.wait"><code>sel4::cap::Notification::wait()</code></a> to signal and then wait on the notification.</p>
<h2 id="step-3e-exercise"><a class="header" href="#step-3e-exercise">Step 3.E (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('0f52649ab1d390861aa8c830aa0cfc57d15224c8')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/0f52649ab1d390861aa8c830aa0cfc57d15224c8"> <i class="fa fa-github"></i> </a></a></h2>
<p>As described in <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#chapter.5">seL4 Reference Manual § 5 (Notifications)</a>, a notification capability can contain a word-sized mask called a badge.
When that capability is used to signal the notification, the notification's word-sized state is bit-wise <code>or</code>ed with the capability's badge.
A wait call on the notification returns and clears the notification's state, provided that a signal call has occurred since the last wait call.</p>
<p><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.AbsoluteCPtr.html#method.mint"><code>sel4::AbsoluteCPtr::mint()</code></a> mints a new capability from an existing capability, updatings its access rights and badge.</p>
<p><strong>Exercise:</strong>: Allocate a new empty slot in the current CNode.</p>
<p>A slot in the root task's CSpace (i.e. a value of type <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/init_thread/struct.Slot.html"><code>sel4::init_thread::Slot</code></a>) can be turned into an <code>sel4::AbsoluteCPtr</code> using {{#rustdoc_link root-task sel4/cap/type.CNode.html#method.absolute_cptr<code>sel4::CNode::absolute_cptr()</code>}}:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/0f52649ab1d390861aa8c830aa0cfc57d15224c8/workspaces/root-task/kernel-objects/src/main.rs#L63-L63">workspaces/root-task/kernel-objects/src/main.rs:63:63 after 3.E</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">            &amp;cnode.absolute_cptr(notification_slot.cptr()),
</code></pre>
</div>
</div>
<p><strong>Exercise:</strong>: Mint a capability based on the capability in <code>notification_slot</code> into your newly allocated slot. Use <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.CapRights.html#method.all"><code>sel4::CapRights::all()</code></a> for the <code>rights</code> parameter, and specify a non-zero badge value.</p>
<p><strong>Exercise:</strong>: Signal the notification using your newly minted badged capability. Using the return value of <code>sel4::Notification::wait()</code>, compare the badge value it returns with the badge you used to mint the capability.</p>
<h2 id="step-3f-exercise"><a class="header" href="#step-3f-exercise">Step 3.F (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('7dc10271914f7a05e682fe9a834a24d2c063d86c')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/7dc10271914f7a05e682fe9a834a24d2c063d86c"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong>: <code>sel4::CapRights::all()</code> is overly-permissive. Use the overly-restrictive <code>sel4::CapRights::none()</code> instead and watch the program fail.</p>
<h2 id="step-3g-exercise"><a class="header" href="#step-3g-exercise">Step 3.G (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('b93bd0cd8304da64bcd722db3f48a68726445b15')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/b93bd0cd8304da64bcd722db3f48a68726445b15"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong>: Now use the minimum rights necessary for the program to run.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="modifying-the-address-space"><a class="header" href="#modifying-the-address-space">Modifying the Address Space</a></h1>
<p>This chapter will focus on using the <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#chapter.7">seL4 virtual address space (VSpace) APIs</a> to manipulate the root task's own address space.
Start by navigating to and running this chapter's example, which, so far, is empty.</p>
<pre><code>cd workspaces/root-task/address-space
make simulate
</code></pre>
<p>In seL4, each thread is associated with a virtual address space (VSpace).
A VSpace is comprised of a tree of translation tables mapping virtual addresses into physical frames of memory.
VSpaces are represented by their root translation structures.
While the high-level virtual address space API concepts are architecture-independent, the specific kernel object types for a given architecture mirror that architecture's paging structures.
That said, all architectures share two object types:</p>
<ul>
<li>The top-level paging structure, called a VSpace, which is used to represent a virtual address space.
In the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/index.html"><code>sel4</code> crate</a>, the corresponding <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/trait.CapType.html"><code>sel4::CapType</code></a> is <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap_type/struct.VSpace.html"><code>sel4::cap_type::VSpace</code></a> (note that, for some architectures, this is a type alias).</li>
<li>Frames of physical memory. The set of possible frames sizes is architecture-dependant.
See <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsection.7.1.3">seL4 Reference Manual § 7.1.3 (Page)</a>.
In the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/index.html"><code>sel4</code> crate</a>, <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap_type/struct.VSpace.html"><code>sel4::cap_type::Granule</code></a> is an alias for the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/trait.CapType.html"><code>sel4::CapType</code></a> corresponding to the smallest frame object type.</li>
</ul>
<p>The root task is provided with capabilites for the objects comprising its own virtual address space.
The locations of these capabilities in the root task's CSpace is provided in the <code>BootInfo</code> struct.
Our goal for this chapter will be to create a frame object and experiment with mapping it into the root task's own address space.</p>
<h2 id="step-4a-exercise"><a class="header" href="#step-4a-exercise">Step 4.A (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('5d99552dd1bcd7b6e0888395e5d5b0f87db57edc')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/5d99552dd1bcd7b6e0888395e5d5b0f87db57edc"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> Using code snippets from <a href="root-task/kernel-objects.html">Chapter 3 (Allocating Kernel Objects)</a>, create a frame object. We seek a value <code>frame: sel4::cap::Granule</code> (which can also be written as <code>frame: sel4::Cap&lt;sel4::cap_type::Granule&gt;</code>).</p>
<p>Note that, after importing the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/trait.CapTypeForObjectOfFixedSize.html"><code>sel4::CapTypeForObjectOfFixedSize</code></a> trait, you can express the appropriate <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/enum.ObjectBlueprint.html"><code>sel4::ObjectBlueprint</code></a> as <code>sel4::cap_type::Granule::object_blueprint()</code>.</p>
<h2 id="step-4b"><a class="header" href="#step-4b">Step 4.B   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('7bd71a7d432c19e080bd2dab9b0a9ebe3898935a')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/7bd71a7d432c19e080bd2dab9b0a9ebe3898935a"> <i class="fa fa-github"></i> </a></a></h2>
<p>In order to avoid interacting with intermediate translation structures, let's reserve an aligned granule-sized region in the root task's program image that we can use for our experiment:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/7bd71a7d432c19e080bd2dab9b0a9ebe3898935a/workspaces/root-task/address-space/src/main.rs#L15-L20">workspaces/root-task/address-space/src/main.rs:15:20 after 4.B</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">const GRANULE_SIZE: usize = sel4::FrameObjectType::GRANULE.bytes(); // 4096

#[repr(C, align(4096))]
struct PagePlaceholder(#[allow(dead_code)] [u8; GRANULE_SIZE]);

static mut PAGE_A: PagePlaceholder = PagePlaceholder([0xee; GRANULE_SIZE]);
</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/7bd71a7d432c19e080bd2dab9b0a9ebe3898935a/workspaces/root-task/address-space/src/main.rs#L46-L49">workspaces/root-task/address-space/src/main.rs:46:49 after 4.B</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    let page_a_addr = ptr::addr_of!(PAGE_A).cast::&lt;u8&gt;();
    sel4::debug_println!("PAGE_A: {page_a_addr:#x?}");
    assert_eq!(page_a_addr as usize % GRANULE_SIZE, 0);
    assert_eq!(unsafe { page_a_addr.read() }, 0xee);
</code></pre>
</div>
</div>
<p>This reservation covers exactly one page in the root task's virtual address space.</p>
<h2 id="step-4c"><a class="header" href="#step-4c">Step 4.C   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('9880c4714f9b7aad818cd4d519359920d0ef9535')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/9880c4714f9b7aad818cd4d519359920d0ef9535"> <i class="fa fa-github"></i> </a></a></h2>
<p>Let's unmap the page in the root task image that initially backs our reserved region. This will give us a hole in the root task VSpace, which we can use for our experiment.</p>
<p>This function determines the slot in the root task's CSpace of the page capability corresponding to the page in the root task's VSpace which contains the given address:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/9880c4714f9b7aad818cd4d519359920d0ef9535/workspaces/root-task/address-space/src/main.rs#L73-L84">workspaces/root-task/address-space/src/main.rs:73:84 after 4.C</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn get_user_image_frame_slot(
    bootinfo: &amp;sel4::BootInfo,
    addr: usize,
) -&gt; sel4::init_thread::Slot&lt;sel4::cap_type::Granule&gt; {
    extern "C" {
        static __executable_start: usize;
    }
    let user_image_addr = ptr::addr_of!(__executable_start) as usize;
    bootinfo
        .user_image_frames()
        .index(addr / GRANULE_SIZE - user_image_addr / GRANULE_SIZE)
}
</code></pre>
</div>
</div>
<p><code>__executable_start</code> is defined by the linker.
We can use it, along with <code>addr</code>, to identify the offset into <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.BootInfo.html#method.user_image_frames"><code>bootinfo.user_image_frames()</code></a> of the capability we are after.</p>
<p>Use the <code>get_user_image_frame_slot()</code> function to find the capability corresponding to the frame backing our reserved region, and unmap that frame, leaving a hole in the root task's virtual address space.
Try to access that region, and observe a page fault:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/9880c4714f9b7aad818cd4d519359920d0ef9535/workspaces/root-task/address-space/src/main.rs#L51-L54">workspaces/root-task/address-space/src/main.rs:51:54 after 4.C</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    let page_a_slot = get_user_image_frame_slot(bootinfo, page_a_addr as usize);
    page_a_slot.cap().frame_unmap().unwrap();

    unsafe { page_a_addr.read() };
</code></pre>
</div>
</div>
<h2 id="step-4d-exercise"><a class="header" href="#step-4d-exercise">Step 4.D (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('4c165ad9826a38c68ee4f3d14f87c2d59172461c')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/4c165ad9826a38c68ee4f3d14f87c2d59172461c"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> Map <code>new_frame</code> at <code>page_a_addr</code> using <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.Cap.html#method.frame_map"><code>new_frame.frame_map()</code></a>, which corresponds to <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsubsection.10.7.6.6">seL4_ARM_Page_Map</a>.</p>
<p>Here are some hints for the parameters of <code>.frame_map()</code>:</p>
<ul>
<li><code>vspace</code>: A capability for the root task's VSpace can be expressed using <code>sel4::init_thread::slot::VSPACE.cap()</code>.</li>
<li><code>rights</code>: <code>sel4::CapRights::read_write()</code> are the most permissive rights, and will work for our purposes.</li>
<li><code>attrs</code>: <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.Cap.html#method.frame_map"><code>sel4::VmAttributes::default()</code></a> will work here.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="using-a-serial-device"><a class="header" href="#using-a-serial-device">Using a Serial Device</a></h1>
<p>In this chapter, we will build a root task that interacts with a serial device.
Start by navigating to and running this chapter's example, which, so far, doesn't do anything interesting.</p>
<pre><code>cd workspaces/root-task/serial-device
make simulate
</code></pre>
<p>The module at <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/42a455f5fbc3a5fb54c2941946a6f9f0ad47d161/workspaces/root-task/serial-device/src/device.rs">device.rs</a> implements a higher-level interface over the serial device's MMIO registers, whose physical base address is:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/42a455f5fbc3a5fb54c2941946a6f9f0ad47d161/workspaces/root-task/serial-device/src/main.rs#L16-L16">workspaces/root-task/serial-device/src/main.rs:16:16</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">const SERIAL_DEVICE_MMIO_PADDR: usize = 0x0900_0000;
</code></pre>
</div>
</div>
<p>Our first goal will be to map the serial device's MMIO registers into the root task's address space.</p>
<p>After that, we will set up the root task's access to the serial device's interrupt, whose value is:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/42a455f5fbc3a5fb54c2941946a6f9f0ad47d161/workspaces/root-task/serial-device/src/main.rs#L18-L18">workspaces/root-task/serial-device/src/main.rs:18:18</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">const SERIAL_DEVICE_IRQ: usize = 33;
</code></pre>
</div>
</div>
<p>Finally, we will implement a simple loop that echoes serial input to serial output.</p>
<h2 id="step-5a"><a class="header" href="#step-5a">Step 5.A   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('4ca8d20363654314ea477148a2c0c45d0c3cbd5e')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/4ca8d20363654314ea477148a2c0c45d0c3cbd5e"> <i class="fa fa-github"></i> </a></a></h2>
<p>First, add some familiar snippets that we will use for allocating CSlots and kernel objects:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/4ca8d20363654314ea477148a2c0c45d0c3cbd5e/workspaces/root-task/serial-device/src/main.rs#L34-L44">workspaces/root-task/serial-device/src/main.rs:34:44 after 5.A</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn find_largest_kernel_untyped(bootinfo: &amp;sel4::BootInfo) -&gt; sel4::cap::Untyped {
    let (ut_ix, _desc) = bootinfo
        .untyped_list()
        .iter()
        .enumerate()
        .filter(|(_i, desc)| !desc.is_device())
        .max_by_key(|(_i, desc)| desc.size_bits())
        .unwrap();

    bootinfo.untyped().index(ut_ix).cap()
}
</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/4ca8d20363654314ea477148a2c0c45d0c3cbd5e/workspaces/root-task/serial-device/src/main.rs#L22-L27">workspaces/root-task/serial-device/src/main.rs:22:27 after 5.A</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    let mut empty_slots = bootinfo
        .empty()
        .range()
        .map(sel4::init_thread::Slot::&lt;sel4::cap_type::Unspecified&gt;::from_index);

    let largest_kernel_ut = find_largest_kernel_untyped(bootinfo);
</code></pre>
</div>
</div>
<h2 id="step-5b-exercise"><a class="header" href="#step-5b-exercise">Step 5.B (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('1d4e99587abf6cdd57593e796ff932898e66bc58')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/1d4e99587abf6cdd57593e796ff932898e66bc58"> <i class="fa fa-github"></i> </a></a></h2>
<p><code>largest_kernel_ut</code> will be useful for allocating kernel objects whose backing physical addresses don't matter to us, but we must allocate the frame which contains the serial device's MMIO registers at a particular physicall address (<code>SERIAL_DEVICE_MMIO_PADDR</code>).
Furthermore, the seL4 API distinguishes between <em>general purpose untyped</em> and <em>device untyped</em>. General purpose untyped is backed by normal memory, and can be used to create any type of object. Device untyped is not backed by normal memory, and can only be used to create frames.
See the last two paragraphs of <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.2.4">seL4 Reference Manual § 2.4 (Kernel Memory Allocation)</a> for more information.
So, we must allocate the serial device MMIO frame from the particular initial device untyped that contains <code>SERIAL_DEVICE_MMIO_PADDR</code>.</p>
<p><strong>Exercice:</strong> Identify this initial untyped in the <code>bootinfo</code>. We will need a corresponding <code>sel4::cap::Untyped</code> along with the untyped's physical address (or <code>sel4::UntypedDesc</code>, which contains the physical address) for the next step.</p>
<h2 id="step-5c"><a class="header" href="#step-5c">Step 5.C   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('37c98443e92fdf315918fba8b9705eef2dadf512')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/37c98443e92fdf315918fba8b9705eef2dadf512"> <i class="fa fa-github"></i> </a></a></h2>
<p>The untyped we've identified contains the frame we are targeting, but that frame may be somewhere in the middle of the region of device memory the untyped covers.
To allocate the frame at <code>SERIAL_DEVICE_MMIO_PADDR</code>, we must allocate dummy objects from this untyped until its watermark is at <code>SERIAL_DEVICE_MMIO_PADDR</code>.</p>
<p>This <code>trim_untyped</code> function takes the untyped capability, its physical address, the desired physical address, and two empty slots for temporarily holding dummy objects.
We need two slots because the kernel resets an untyped's watermark if it has no live children.
So, we must always keep one child around so that our progress on advancing the watermark is never lost.</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/37c98443e92fdf315918fba8b9705eef2dadf512/workspaces/root-task/serial-device/src/main.rs#L43-L49">workspaces/root-task/serial-device/src/main.rs:43:49 after 5.C</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    trim_untyped(
        device_ut_cap,
        device_ut_desc.paddr(),
        SERIAL_DEVICE_MMIO_PADDR,
        empty_slots.next().unwrap(),
        empty_slots.next().unwrap(),
    );
</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/37c98443e92fdf315918fba8b9705eef2dadf512/workspaces/root-task/serial-device/src/main.rs#L68-L97">workspaces/root-task/serial-device/src/main.rs:68:97 after 5.C</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn trim_untyped(
    ut: sel4::cap::Untyped,
    ut_paddr: usize,
    target_paddr: usize,
    free_slot_a: sel4::init_thread::Slot,
    free_slot_b: sel4::init_thread::Slot,
) {
    let rel_a = sel4::init_thread::slot::CNODE
        .cap()
        .absolute_cptr(free_slot_a.cptr());
    let rel_b = sel4::init_thread::slot::CNODE
        .cap()
        .absolute_cptr(free_slot_b.cptr());
    let mut cur_paddr = ut_paddr;
    while cur_paddr != target_paddr {
        let size_bits = (target_paddr - cur_paddr).ilog2().try_into().unwrap();
        ut.untyped_retype(
            &amp;sel4::ObjectBlueprint::Untyped { size_bits },
            &amp;sel4::init_thread::slot::CNODE
                .cap()
                .absolute_cptr_for_self(),
            free_slot_b.index(),
            1,
        )
        .unwrap();
        rel_a.delete().unwrap();
        rel_a.move_(&amp;rel_b).unwrap();
        cur_paddr += 1 &lt;&lt; size_bits;
    }
}
</code></pre>
</div>
</div>
<h2 id="step-5d"><a class="header" href="#step-5d">Step 5.D   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('e53700e1f3e3422f8dae8bfa5e51082021ff5a8d')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/e53700e1f3e3422f8dae8bfa5e51082021ff5a8d"> <i class="fa fa-github"></i> </a></a></h2>
<p><code>device_ut_cap</code> is now primed; the physical address of the next allocation will be <code>SERIAL_DEVICE_MMIO_PADDR</code>.</p>
<p><strong>Exercise:</strong> Allocate a small frame object (<code>sel4::cap_type::Granule</code>) from <code>device_ut_cap</code>.</p>
<p>If your <code>sel4::cap::Granule</code> is called <code>serial_device_frame_cap</code>, then the following assertion should succeed:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/e53700e1f3e3422f8dae8bfa5e51082021ff5a8d/workspaces/root-task/serial-device/src/main.rs#L70-L73">workspaces/root-task/serial-device/src/main.rs:70:73 after 5.D</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    assert_eq!(
        serial_device_frame_cap.frame_get_address().unwrap(),
        SERIAL_DEVICE_MMIO_PADDR
    );
</code></pre>
</div>
</div>
<h2 id="step-5e-exercise"><a class="header" href="#step-5e-exercise">Step 5.E (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('f777327b2723bd850a1fe35ae2679e668d09ed2b')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/f777327b2723bd850a1fe35ae2679e668d09ed2b"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> Using code from <a href="root-task/./address-space.html#step-4b">Step 4.B</a>, <a href="root-task/./address-space.html#step-4c">Step 4.C</a>, and <a href="root-task/./address-space.html#step-4d-exercise">Step 4.D</a>, map <code>serial_device_frame_cap</code> into the root task's virtual address space.</p>
<p>You should now be able interact with the serial device's MMIO registers.
Try printing "Hello, World!" to the serial console with something like:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/f777327b2723bd850a1fe35ae2679e668d09ed2b/workspaces/root-task/serial-device/src/main.rs#L102-L108">workspaces/root-task/serial-device/src/main.rs:102:108 after 5.E</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">    let serial_device = unsafe { Device::new(serial_device_mmio_page_addr.cast()) };

    serial_device.init();

    for c in b"Hello, World!\n" {
        serial_device.put_char(*c);
    }
</code></pre>
</div>
</div>
<p>where <code>serial_device_mmio_page_addr: *mut _</code> is a pointer to where the MMIO registers are mapped in the root task's virtual address space.</p>
<h2 id="step-5f-exercise"><a class="header" href="#step-5f-exercise">Step 5.F (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('821f5c9d6e6b0e0f8d01f8cbc51e27e1e9090b38')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/821f5c9d6e6b0e0f8d01f8cbc51e27e1e9090b38"> <i class="fa fa-github"></i> </a></a></h2>
<p>Interrupts are delivered to userspace via notifications.
A <code>IRQHandler</code> capability represents the authority to manage a particular interrupt.
Specifically, an <code>IRQHandler</code> capability (<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.IrqHandler.html"><code>sel4::cap::IrqHandler</code></a>) has the following methods:</p>
<ul>
<li><a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsubsection.10.3.4.3"><code>seL4_IRQHandler_SetNotification()</code></a>:
Associate the interrupt with the given notification. Userspace can call <code>seL4_Wait()</code> or <code>seL4_Poll()</code> on this notification to receive the interrupt.</li>
<li><a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsubsection.10.3.4.3"><code>seL4_IRQHandler_Clear()</code></a>:
Disassociate the notification associated with this interrupts.</li>
<li><a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsubsection.10.3.4.3"><code>seL4_IRQHandler_Ack()</code></a>:
Tell the kernel to pass on acknowledgement of this interrupt to the interrupt controller.</li>
</ul>
<p>The Rust bindings for these methods are:</p>
<ul>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.IrqHandler.html#method.irq_handler_set_notification"><code>sel4::cap::IrqHandler::irq_handler_set_notification()</code></a></li>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.IrqHandler.html#method.irq_handler_clear"><code>sel4::cap::IrqHandler::irq_handler_clear()</code></a></li>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.IrqHandler.html#method.irq_handler_ack"><code>sel4::cap::IrqHandler::irq_handler_ack()</code></a></li>
</ul>
<p>The root task spawns with a special <code>IRQControl</code> capability (<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.IrqControl.html"><code>sel4::cap::IrqControl</code></a>) which can be used to create <code>IRQHandler</code> capabilities with <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsubsection.10.3.3.1"><code>seL4_IRQControl_Get()</code></a> (<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.IrqControl.html#method.irq_control_get"><code>sel4::cap::IrqControl::irq_control_get()</code></a>).</p>
<p>The intent behind this API is that a highly-privileged component will hold an <code>IRQControl</code> capability, which it will use to distribute more finely-grained <code>IRQHandler</code> capabilities to less privileged components for the interrupts they will manage.</p>
<p>The root task can access its <code>IRQControl</code> capability with <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/init_thread/slot/constant.IRQ_CONTROL.html"><code>sel4::init_thread::slot::IRQ_CONTROL.cap()</code></a></p>
<p><strong>Exercise:</strong> Use <code>sel4::init_thread::slot::IRQ_CONTROL.cap()</code> to create a <code>sel4::cap::IrqHandler</code> for <code>SERIAL_DEVICE_IRQ</code>.</p>
<h2 id="step-5g-exercise"><a class="header" href="#step-5g-exercise">Step 5.G (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('4c70bab21f52c4d61408b37adc556f5377e93625')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/4c70bab21f52c4d61408b37adc556f5377e93625"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> Create a notification object from <code>largest_kernel_ut</code> and associate it with the <code>IRQHandler</code> you just created using <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.IrqHandler.html#method.irq_handler_set_notification"><code>sel4::cap::IrqHandler::irq_handler_set_notification()</code></a>.</p>
<h2 id="step-5h-exercise"><a class="header" href="#step-5h-exercise">Step 5.H (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('8c646af48d71fc0bb9d5a6a9d4ef17b624b07ed0')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/8c646af48d71fc0bb9d5a6a9d4ef17b624b07ed0"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> Use <code>serial_device: Device</code>, your <code>IRQHandler</code>, and the notification you associated with the interrupt to write a loop that echoes serial input to serial output.</p>
<p>Use <code>serial_device.clear_all_interrupts()</code> and <code>irq_handler_cap.irq_handler_ack()</code> in sequence to clear the interrupt at the device and interrupt controller levels respectively.
Note that you should do this at the beginning of the loop in case your loop enters with an interrupt already pending.</p>
<p>Use <code>irq_notification_cap.wait()</code> to wait for hte interrupt.</p>
<p>Use <code>serial_device.get_char()</code> and <code>serial_device.put_char()</code> to read and write data.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="spawning-a-thread"><a class="header" href="#spawning-a-thread">Spawning a Thread</a></h1>
<p>In this chapter, we will explore IPC through an example that spawns a secondary thread.
This example starts with a more interesting program than the other examples we've worked with so far.
It spawns a secondary thread, and then interacts with it using a notification.</p>
<p>Navigate to and run the example:</p>
<pre><code>cd workspaces/root-task/spawn-thread
make simulate
</code></pre>
<p>Explore <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/4bc0ad04dd0baa65772186e97381166b802e814b/workspaces/root-task/spawn-thread/src/main.rs">main.rs</a> at will.
If you're used to using <a href="https://github.com/seL4/seL4_libs">seL4_libs</a>, you may notice that our Rust code here is much more low-level and verbose.
That is because we aren't using any higher-level seL4-related libraries such as
<a href="https://github.com/seL4/seL4_libs/blob/master/libsel4utils/include/sel4utils/thread.h"><code>&lt;sel4utils/thread.h&gt;</code></a>.
Our code is more like spawning a thread using <code>&lt;sel4/sel4.h&gt;</code> alone.
Note, though, that our code does depend on a few Rust language runtime building block crates such as
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_initialize_tls/index.html"><code>sel4-initialize-tls</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_stack/index.html"><code>sel4-stack</code></a>
.</p>
<p>The exercises in this chapter are only concerned with the following two functions, which run concurrently:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/4bc0ad04dd0baa65772186e97381166b802e814b/workspaces/root-task/spawn-thread/src/main.rs#L75-L79">workspaces/root-task/spawn-thread/src/main.rs:75:79</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn secondary_thread_main(inter_thread_nfn: sel4::cap::Notification) {
    sel4::debug_println!("In secondary thread");

    inter_thread_nfn.signal();
}
</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/4bc0ad04dd0baa65772186e97381166b802e814b/workspaces/root-task/spawn-thread/src/main.rs#L81-L85">workspaces/root-task/spawn-thread/src/main.rs:81:85</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn interact_with_secondary_thread(inter_thread_nfn: sel4::cap::Notification) {
    sel4::debug_println!("In primary thread");

    inter_thread_nfn.wait();
}
</code></pre>
</div>
</div>
<p><code>secondary_thread_main()</code> runs in the secondary thread, and <code>interact_with_secondary_thread()</code> runs in the secondary thread.</p>
<h2 id="step-6a"><a class="header" href="#step-6a">Step 6.A   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('c4acc79f48ccdfb280444c9b41280893b6c810dd')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/c4acc79f48ccdfb280444c9b41280893b6c810dd"> <i class="fa fa-github"></i> </a></a></h2>
<p>In this step, we introduce IPC between <code>secondary_thread_main()</code> and <code>interact_with_secondary_thread</code> by changing</p>
<pre><code>inter_thread_nfn: sel4::cap::Notification
</code></pre>
<p>to</p>
<pre><code>inter_thread_ep: sel4::cap::Endpoint
</code></pre>
<p>Before, the two sides of the notification communicated via
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Notification.html#method.signal"><code>inter_thread_nfn.signal()</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Notification.html#method.wait"><code>inter_thread_nfn.wait()</code></a>.</p>
<p>Now, communication over this IPC endpoint will happen by
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Endpoint.html#method.send"><code>inter_thread_ep.send()</code></a> and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Endpoint.html#method.recv"><code>inter_thread_ep.recv()</code></a>
.</p>
<!-- , as described in
[seL4 Reference Manual § 4.2 (Endpoints)](https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.4.2). -->
<p>As described in <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#chapter.4">seL4 Reference Manual § 4 (Message Passing (IPC))</a> and <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#section.4.2">seL4 Reference Manual § 4.2 (Endpoints)</a>, a capability for an Endpoint object can be invoked with <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Endpoint.html#method.send"><code>send()</code></a> and <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Endpoint.html#method.recv"><code>recv()</code></a>.
<code>send()</code> and <code>recv()</code> block until the two sides of the object rendezvous, at which point a message is passed from the sender to the receiver.
This message may contain data and capabilities.</p>
<p>Each thread is associated with a special page of memory called an IPC buffer.
The sender populates its own IPC buffer with data and/or CPtrs, and then calls <code>send()</code> with a metadata value called the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.MessageInfo.html"><code>MessageInfo</code></a>.
The kernel copies data from the sender's IPC buffer into that of the receiver, and/or capabilities from the sender's CSpace into that of the receiver.
The kernel uses the <code>MessageInfo</code> to determine how much data to copy between the two IPC buffers
(the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.MessageInfo.html#method.length"><code>length</code></a> field)
and how many CPtrs to read from the IPC buffers for copying betwen CSpaces
(the
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.MessageInfo.html#method.caps_unwrapped"><code>caps_unwrapped</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.MessageInfo.html#method.extra_caps"><code>extra_caps</code></a>
fields).
Finally, the kernel passes the <code>MessageInfo</code>, and control, to the receiver.</p>
<p>In Rust, the sender and receiver can interact with their own IPC buffer using
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/fn.with_ipc_buffer.html"><code>sel4::with_ipc_buffer</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/fn.with_ipc_buffer_mut.html"><code>sel4::with_ipc_buffer_mut</code></a>.
Message data is held in the message registers (an array of machine words), which is a field of the IPC buffer (
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.IpcBuffer.html#method.msg_regs"><code>msg_regs</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.IpcBuffer.html#method.msg_regs_mut"><code>msg_regs_mut</code></a>
).
The <code>length</code> field of the <code>MessageInfo</code> specifies how many message registers will be copied into the receiver's IPC buffer.</p>
<p>One can also view the message registers as an array of bytes using
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.IpcBuffer.html#method.msg_bytes"><code>msg_bytes</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.IpcBuffer.html#method.msg_bytes_mut"><code>msg_bytes_mut</code></a>.
In this case, one rounds the length of their message up to the nearest multiple of the machine word size when computing the message length for the <code>MessageInfo</code>.</p>
<p>The <code>MessageInfo</code> also includes a few bits of data called a <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.MessageInfo.html#method.label"><code>label</code></a> (<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.MessageInfo.html#method.label_width"><code>label_width</code></a> bits wide) that is not interpreted by the kernel.</p>
<p>In Rust, the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.MessageInfoBuilder.html"><code>MessageInfoBuilder</code></a> type is a clear and concise way to construct a <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/struct.MessageInfo.html"><code>MessageInfo</code></a>.</p>
<p>In Rust, to smooth out differences between the mixed-criticality and legacy kernel schedulers, <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Endpoint.html#method.recv"><code>recv()</code></a> always takes a <code>reply_authority</code> argument.
Under legacy scheduler configurations, which is what this text uses, this argument can be of type <code>()</code>.</p>
<p>Taking all of this together, let's use our IPC endpoint to send an empty message:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/c4acc79f48ccdfb280444c9b41280893b6c810dd/workspaces/root-task/spawn-thread/src/main.rs#L75-L79">workspaces/root-task/spawn-thread/src/main.rs:75:79 after 6.A</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn secondary_thread_main(inter_thread_ep: sel4::cap::Endpoint) {
    sel4::debug_println!("In secondary thread");

    inter_thread_ep.send(sel4::MessageInfoBuilder::default().label(123).build());
}
</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/c4acc79f48ccdfb280444c9b41280893b6c810dd/workspaces/root-task/spawn-thread/src/main.rs#L81-L87">workspaces/root-task/spawn-thread/src/main.rs:81:87 after 6.A</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn interact_with_secondary_thread(inter_thread_ep: sel4::cap::Endpoint) {
    sel4::debug_println!("In primary thread");

    let (msg_info, _badge) = inter_thread_ep.recv(());

    assert_eq!(msg_info.label(), 123);
}
</code></pre>
</div>
</div>
<h2 id="step-6b-exercise"><a class="header" href="#step-6b-exercise">Step 6.B (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('b8d896bce9c35f6d479435c93240c766d74c9bd7')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/b8d896bce9c35f6d479435c93240c766d74c9bd7"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong> use
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/fn.with_ipc_buffer.html"><code>sel4::with_ipc_buffer</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/fn.with_ipc_buffer_mut.html"><code>sel4::with_ipc_buffer_mut</code></a>
to send a message with some data.</p>
<h2 id="step-6c-exercise"><a class="header" href="#step-6c-exercise">Step 6.C (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('968473d5d4d0fd205a7f5162be1477ea337ff4fa')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/968473d5d4d0fd205a7f5162be1477ea337ff4fa"> <i class="fa fa-github"></i> </a></a></h2>
<p>See <a href="https://sel4.systems/Info/Docs/seL4-manual-13.0.0.pdf#subsection.4.2.4">seL4 Reference Manual § 4.2.4 (Calling and Replying)</a> for a description of the <code>seL4_Call</code> syscall (<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/cap/type.Endpoint.html#method.call"><code>Endpoint::call()</code></a> in Rust).</p>
<p><strong>Exercise:</strong> Change the</p>
<pre><code>inter_thread_ep.send()
</code></pre>
<p>in <code>secondary_thread_main()</code> to</p>
<pre><code>inter_thread_ep.call()
</code></pre>
<p>and modify <code>interact_with_secondary_thread()</code> to <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4/fn.reply.html"><code>sel4::reply</code></a> with a message.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="spawning-a-task-challenge"><a class="header" href="#spawning-a-task-challenge">Spawning a Task (Challenge)</a></h1>
<p>This final chapter of Part I contains a more open-ended and challenging exercise.
We start with an example that spawns an entire new process, which, in the context of low-level seL4 userspace, is often called a <em>task</em>:</p>
<pre><code>cd workspaces/root-task/spawn-task
make simulate
</code></pre>
<p>Similarly to what we saw in <a href="root-task/spawn-thread.html">Chapter 6 (Spawning a Thread)</a>, the code in this example is more low-level and complex compared to what you have seen in code that leverages <a href="https://github.com/seL4/seL4_libs/blob/master/libsel4utils/include/sel4utils/process.h"><code>&lt;sel4utils/process.h&gt;</code></a>.
Again, our code here is more like spawning a task using <code>&lt;sel4/sel4.h&gt;</code> alone.</p>
<p>This example consists of two programs.
The <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/40312f3193ef51692da43172bb9feab8a200a157/workspaces/root-task/spawn-task/src/main.rs"><code>spawn-task</code></a> crate is the root task, and the <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/40312f3193ef51692da43172bb9feab8a200a157/workspaces/root-task/spawn-task/child/src/main.rs"><code>spawn-task-child</code></a> crate is the child task.</p>
<p>The child task does not spawn in any standard sort of environment, so is includes its own ad-hoc Rust language runtime in <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/40312f3193ef51692da43172bb9feab8a200a157/workspaces/root-task/spawn-task/child/src/runtime.rs">child/src/runtime.rs</a>, complete with thread-local storage, a global heap allocator, and exception handling.
This runtime is built using a few Rust langauge runtime building block crates:</p>
<ul>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_runtime_common/index.html"><code>sel4-runtime-common</code></a></li>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_initialize_tls/index.html"><code>sel4-initialize-tls</code></a></li>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_dlmalloc/index.html"><code>sel4-dlmalloc</code></a></li>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_stack/index.html"><code>sel4-stack</code></a></li>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_panicking/index.html"><code>sel4-panicking</code></a></li>
<li><a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_panicking_env/index.html"><code>sel4-panicking-env</code></a></li>
</ul>
<p>This minimal, ad-hoc language runtime is a neat, instructive piece of code.
It shows how one can build a new Rust language runtime out of the building blocks provided by the <a href="https://github.com/seL4/rust-sel4">rust-sel4</a> project.</p>
<p>Explore the <a href="https://github.com/seL4/seL4-rust-tutorial-code/tree/40312f3193ef51692da43172bb9feab8a200a157/workspaces/root-task/spawn-task/src">root task</a> and <a href="https://github.com/seL4/seL4-rust-tutorial-code/tree/40312f3193ef51692da43172bb9feab8a200a157/workspaces/root-task/spawn-task/child/src">child task</a>.</p>
<p>Right now, all the child task does is send a test message over an endpoint back to the root task.
The challenge in this chapter, <a href="root-task/spawn-task.html#step-7e-challenge">step 7.E</a>, is to extend the root task so that it sets up the child task to be able to interact with the serial device, and to extend the child task to implement the same echo loop as in [./serial-device.html#step-5h].
Steps <a href="root-task/spawn-task.html#step-7a">7.A</a>, <a href="root-task/spawn-task.html#step-7b">7.B</a>, <a href="root-task/spawn-task.html#step-7c">7.C</a>, and <a href="root-task/spawn-task.html#step-7d">7.D</a>, which are not exercises, make some incremental extensions towards those goals to help you get started.</p>
<h2 id="step-7a"><a class="header" href="#step-7a">Step 7.A   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('73b4d16c157a57c029da1b8e47ea94748a1a08d8')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/73b4d16c157a57c029da1b8e47ea94748a1a08d8"> <i class="fa fa-github"></i> </a></a></h2>
<p>This step extends the <code>ObjectAllocator</code> type in <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/bb8a992c4b3944f2a93fdd303921d4dba2002b4e/workspaces/root-task/spawn-task/src/object_allocator.rs">workspaces/root-task/spawn-task/src/object_allocator.rs after 7.B</a> with the <code>recklessly_allocate_at()</code> method.
This method allocates an object according to the <code>blueprint</code> parameter at the given physical address <code>paddr</code>.
Instead of just allocating the object from the largest kernel untyped like the <code>allocate()</code> method does, this method searches through the bootinfo to find the initial untyped capability whose corresponding untyped object contains <code>paddr</code>, allocates dummy objects from this untyped object until its watermark reaches <code>paddr</code>, and then allocates the desired object.
<code>recklessly_allocate_at()</code>'s procedure is similar to that which we followed in <a href="root-task/./serial-device.html#step-5c">step 5.C</a>.</p>
<p>This implementation is "reckless" because it modifies the state of the untyped capability it allocates from (allocating from it and changing its watermark) without keeping track of having done so.
So, subsequent calls for <code>paddr</code>s contained in the same initial untyped would fail or, worse, misbehave.
However, we expect to only need to call it once, so we are okay with this caveat.</p>
<p>In <a href="root-task/spawn-task.html#step-7e-challenge">step 7.E</a>, you be able to use this method to allocate the serial device MMIO register frame.</p>
<h2 id="step-7b"><a class="header" href="#step-7b">Step 7.B   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('bb8a992c4b3944f2a93fdd303921d4dba2002b4e')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/bb8a992c4b3944f2a93fdd303921d4dba2002b4e"> <i class="fa fa-github"></i> </a></a></h2>
<p>This step extends the <code>create_child_vspace()</code> function in <a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/73b4d16c157a57c029da1b8e47ea94748a1a08d8/workspaces/root-task/spawn-task/src/child_vspace.rs">workspaces/root-task/spawn-task/src/child_vspace.rs after 7.A</a> to take an <code>extra_frames</code> parameter.
<code>create_child_vspace()</code> now maps these extra frames into the child task's address space, after the end of the program image, and after the IPC buffer frame.</p>
<p>In <a href="root-task/spawn-task.html#step-7e-challenge">step 7.E</a>, you be able to use this parameter to pass in the serial device MMIO register frame to mapped into the child task's address space.</p>
<h2 id="step-7c"><a class="header" href="#step-7c">Step 7.C   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('a402baec43efdd31a8dcfc70cc152da039dcc516')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/a402baec43efdd31a8dcfc70cc152da039dcc516"> <i class="fa fa-github"></i> </a></a></h2>
<p>This step simply copies the <code>Device</code> type from <a href="root-task/./serial-device.html">chapter 5</a> into the child task.</p>
<p>In <a href="root-task/spawn-task.html#step-7e-challenge">step 7.E</a>, you be able to use this type to interact with the serial device's MMIO registers, just like we as part of <a href="root-task/./serial-device.html#step-5e-exercise">step 5.E</a>.</p>
<h2 id="step-7d"><a class="header" href="#step-7d">Step 7.D   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('e5cb0e8d6e27889e5801ac04189972cdf953cdaf')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/e5cb0e8d6e27889e5801ac04189972cdf953cdaf"> <i class="fa fa-github"></i> </a></a></h2>
<p>This step just adds the <code>SERIAL_DEVICE_MMIO_PADDR</code> and <code>SERIAL_DEVICE_IRQ</code> constants from <a href="root-task/./serial-device.html">chapter 5</a> to the root task.</p>
<h2 id="step-7e-challenge"><a class="header" href="#step-7e-challenge">Step 7.E (challenge)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('ddfc44092299c6dfbc9f214e3144f7e201cc6971')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/ddfc44092299c6dfbc9f214e3144f7e201cc6971"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong>
Extend the root task so that it sets up the child task to be able to interact with the serial device, and extend the child task to implement the same echo loop as in [./serial-device.html#step-5h-exercise].</p>
<div class="step-hint">
<details>
    <summary>
        Hint for the root task (click to expand)
    </summary>
<p>Try following this sequence of sub-steps:
- Allocate <code>serial_device_frame_cap: sel4::cap::Granule</code> using <code>object_allocator.recklessly_allocate_at()</code>.
- Map <code>serial_device_frame_cap</code> into the child task's address space using <code>create_child_vspace()</code>'s <code>extra_frames</code> parameter.
- Similarly to how we did so in steps <a href="root-task/./serial-device.html#step-5f-exercise">5.F</a> and <a href="root-task/./serial-device.html#step-5g-exercise">5.G</a>, obtain <code>irq_handler_cap: sel4::cap::IrqHandler</code> for <code>SERIAL_DEVICE_IRQ</code> (<code>object_allocator.allocate_slot()</code> might come in handy), allocate <code>irq_nfn_cap: sel4::cap::Notification</code>, and associate <code>irq_nfn_cap</code> with <code>SERIAL_DEVICE_IRQ</code> using <code>irq_handler_cap</code>.
- Copy <code>irq_handler_cap</code> and <code>irq_nfn_cap</code> into the child task's CSpace in a similar way to how <code>child_tcb</code> and <code>inter_task_ep</code> are copied.</p>
</details>
</div>
<p></p>
<div class="step-hint">
<details>
    <summary>
        Hint for the child task (click to expand)
    </summary>
<p>Try following this sequence of sub-steps:
- Declare constants <code>IRQ_HANDLER: sel4::cap::IrqHandler</code> and <code>IRQ_NFN: sel4::cap::Notification</code> after <code>OWN_TCB</code> and <code>INTRA_TASK_EP</code>.
- Obtain the virtual address of the serial device MMIO frame with <code>addr_of_page_beyond_image(1)</code> (recall how <code>create_child_vspace()</code>'s <code>extra_frames</code> parameter works).
- Initialize the serial device with <code>Device::new()</code> and <code>Device::init()</code> (as we did for part of <a href="root-task/./serial-device.html#step-5e-exercise">step 5.E</a>), and use the serial device just like we did in <a href="root-task/./serial-device.html#step-5h-exercise">step 5.H</a>.</p>
</details>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="sel4-microkit"><a class="header" href="#sel4-microkit">seL4 Microkit</a></h1>
<p>The <a href="https://github.com/seL4/microkit">seL4 Microkit</a> is a framework for creating static systems based on seL4.
This part of the text assumes that the reader is familiar with the basics of the Microkit framework and API, or is using a companion resource to learn about the Microkit in parallel.
Here are three such resources:</p>
<ul>
<li>The <a href="https://github.com/seL4/microkit/blob/main/docs/manual.md">Mirokit manual</a></li>
<li>The <a href="https://trustworthy.systems/projects/microkit/tutorial/welcome.html">Mirokit tutorial</a></li>
</ul>
<p>This part also assumes that the reader has worked through chapters <a href="microkit/../root-task/hello-world.html">2</a> and <a href="microkit/../root-task/spawn-thread.html">6</a> of <a href="microkit/../root-task/index.html">Part I</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="hello-world-1"><a class="header" href="#hello-world-1">Hello, World!</a></h1>
<p>Navigate to and run the hello world Microkit example:</p>
<pre><code>cd workspaces/microkit/hello-world
make simulate
</code></pre>
<p>Here is its source:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/a167640582bb329ccd5ecf0113f0cd8492ab616f/workspaces/microkit/hello-world/pds/hello/src/main.rs#L7-L22">hello-world/pds/hello/src/main.rs:7:22</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use sel4_microkit::{debug_println, protection_domain, Handler, Infallible};

#[protection_domain]
fn init() -&gt; impl Handler {
    debug_println!("Hello, World!");
    HandlerImpl
}

struct HandlerImpl;

impl Handler for HandlerImpl {
    type Error = Infallible;
}
</code></pre>
</div>
</div>
<p>The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/index.html"><code>sel4_microkit</code> crate</a> implements a Rust language runtime for Microkit protection domains, and implements the Microkit API.
It is written in pure Rust, and does not link against <a href="https://github.com/seL4/microkit/blob/main/libmicrokit"><code>libmicrokit</code></a>.</p>
<h3 id="the-event-handler"><a class="header" href="#the-event-handler">The Event Handler</a></h3>
<p>The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/attr.protection_domain.html"><code>#[protection_domain]</code></a> attribute macro declares a function to be the protection domain's initialization function.
The entrypoint function must have a signature of the form:</p>
<pre><code class="language-rust ignore">fn() -&gt; T
where
    T: sel4_microkit::Handler</code></pre>
<p>An implementation of the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/trait.Handler.html"><code>Handler</code></a> trait is used by the runtime as the event handler for the protection domain's main loop.
The
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/trait.Handler.html#method.notified"><code>notified</code></a>,
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/trait.Handler.html#method.protected"><code>protected</code></a>,
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/trait.Handler.html#method.fault"><code>fault</code></a>
methods correspond to their equivalents in <a href="https://github.com/seL4/microkit/blob/main/libmicrokit/include/microkit.h"><code>&lt;microkit.h&gt;</code></a>.</p>
<p>The default implementations of these methods just panic.
Our event handler, which we've called <code>HandlerImpl</code>, is the simplest possible <code>Handler</code> implementation.</p>
<h3 id="language-runtime"><a class="header" href="#language-runtime">Language Runtime</a></h3>
<p>As detailed in its rustdoc, the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/attr.protection_domain.html"><code>#[protection_domain]</code></a> attribute macro takes the same parameters as <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/root-task/aarch64-sel4-unwind/doc/sel4_root_task/attr.root_task.html"><code>#[root_task]</code></a>.
Furthermore, the <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/index.html"><code>sel4_microkit</code></a> crate supports all of the same Rust language runtime elements that we explored in <a href="microkit/../root-task/hello-world.html">Chapter 2</a>, including
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/panicking/fn.catch_unwind.html"><code>sel4_microkit::panicking::catch_unwind()</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/panicking/fn.set_hook.html"><code>sel4_microkit::panicking::set_hook()</code></a>
.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="ipc"><a class="header" href="#ipc">IPC</a></h1>
<p>This chapter covers making and handling protected procedure calls in protection domains written in Rust.
Navigate to and run the example:</p>
<pre><code>cd workspaces/microkit/ipc
make simulate
</code></pre>
<p>The example system description specifies two protection domains, with a channel between them:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/5d7ed9ed19340cff0208953146230e391d7c8a07/workspaces/microkit/ipc/ipc.system#L7-L20">ipc.system:7:20</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-xml">&lt;system&gt;
    &lt;protection_domain name="client" priority="100"&gt;
        &lt;program_image path="microkit-ipc-client.elf" /&gt;
    &lt;/protection_domain&gt;

    &lt;protection_domain name="server" priority="200"&gt;
        &lt;program_image path="microkit-ipc-server.elf" /&gt;
    &lt;/protection_domain&gt;

    &lt;channel&gt;
        &lt;end pd="client" id="13" pp="true" /&gt;
        &lt;end pd="server" id="37" /&gt;
    &lt;/channel&gt;
&lt;/system&gt;

</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/5d7ed9ed19340cff0208953146230e391d7c8a07/workspaces/microkit/ipc/pds/client/src/main.rs#L14-L36">pds/client/src/main.rs:14:36</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">const SERVER: Channel = Channel::new(13);

#[protection_domain]
fn init() -&gt; impl Handler {
    debug_println!("client: initializing");
    HandlerImpl
}

struct HandlerImpl;

impl Handler for HandlerImpl {
    type Error = Infallible;

    fn notified(&amp;mut self, channels: ChannelSet) -&gt; Result&lt;(), Self::Error&gt; {
        debug_println!("client: notified by {}", channels.display());

        if channels.contains(SERVER) {
            debug_println!("client: TEST_PASS");
        }

        Ok(())
    }
}
</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/5d7ed9ed19340cff0208953146230e391d7c8a07/workspaces/microkit/ipc/pds/server/src/main.rs#L12-L39">pds/server/src/main.rs:12:39</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">const CLIENT: Channel = Channel::new(37);

#[protection_domain]
fn init() -&gt; impl Handler {
    debug_println!("server: initializing");

    debug_println!("server: notifying client");

    CLIENT.notify();

    HandlerImpl
}

struct HandlerImpl;

impl Handler for HandlerImpl {
    type Error = Infallible;

    fn protected(
        &amp;mut self,
        channel: Channel,
        msg_info: MessageInfo,
    ) -&gt; Result&lt;MessageInfo, Self::Error&gt; {
        debug_println!("server: called by {:?}", channel);

        todo!()
    }
}
</code></pre>
</div>
</div>
<p>The
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/struct.Channel.html"><code>Channel</code></a> type is the Rust equivalent of the
<a href="https://github.com/seL4/microkit/blob/b8cf3094ba08b37198b1943ec832c3a1168f4409/libmicrokit/include/microkit.h#L14C22-L14C38">microkit_channel</a>
type alias in <code>libmicrokit</code>.
Note how the functionality corresponding to <code>libmicrokit</code>'s <code>microkit_notify</code>, <code>microkit_irq_ack</code>, and <code>microkit_ppcall</code> is implemented in methods for <code>Channel</code>.</p>
<p>The
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/struct.MessageInfo.html"><code>MessageInfo</code></a> type is the Rust equivalent of the
<a href="https://github.com/seL4/microkit/blob/b8cf3094ba08b37198b1943ec832c3a1168f4409/libmicrokit/include/microkit.h#L16C28-L16C44">microkit_msginfo</a>
type alias in <code>libmicrokit</code>.
Just as <code>microkit_msginfo</code> is an alias for <code>seL4_MessageInfo_t</code>, <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/struct.MessageInfo.html"><code>sel4_microkit::MessageInfo</code></a> is just a thin wrapper around <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4/struct.MessageInfo.html"><code>MessageInfo</code></a>.</p>
<p><code>libmicrokit</code> has <code>microkit_mr_set()</code> and <code>microkit_mr_get()</code> for interacting with the IPC buffer.
In the <code>sel4_microkit</code> crate, we have
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/fn.get_mr.html"><code>get_mr()</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/fn.set_mr.html"><code>set_mr()</code></a>
,
but we also have
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/fn.with_msg_regs.html"><code>with_msg_regs()</code></a>,
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/fn.with_msg_regs_mut.html"><code>with_msg_regs_mut()</code></a>,
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/fn.with_msg_bytes.html"><code>with_msg_bytes()</code></a>, and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/fn.with_msg_bytes_mut.html"><code>with_msg_bytes_mut()</code></a>,
which use
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4/fn.with_ipc_buffer.html"><code>sel4::with_ipc_buffer()</code></a> and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4/fn.with_ipc_buffer_mut.html"><code>sel4::with_ipc_buffer_mut()</code></a> under the hood.</p>
<h2 id="step-10a-exercise"><a class="header" href="#step-10a-exercise">Step 10.A (exercise)   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('7bd4b3a57ec358e3c50a61a63c27ecbc6593d160')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/7bd4b3a57ec358e3c50a61a63c27ecbc6593d160"> <i class="fa fa-github"></i> </a></a></h2>
<p><strong>Exercise:</strong>
In the client's <code>notified()</code> handler, make a protected procedure call to the server using <code>SERVER.pp_call()</code>.
Handle the call in the server's <code>protected()</code> handler.
Include data in the message using <code>sel4_microkit::with_msg_regs{,_mut}</code>.</p>
<p><strong>Exercise (optional):</strong>
Send something more interesting over IPC using
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4/struct.IpcBuffer.html#method.msg_bytes"><code>msg_bytes</code></a>
and
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4/struct.IpcBuffer.html#method.msg_bytes_mut"><code>msg_bytes_mut</code></a>
.
For example, the <a href="https://docs.rs/zerocopy/latest/zerocopy/"><code>zerocopy</code> crate</a> can be used to view certain types as bytes and vice versa, and the lightweight <a href="https://docs.rs/postcard/latest/postcard/"><code>postcard</code> crate</a> can be used to serialize and deserialize a wider range of types using <a href="https://serde.rs/"><code>serde</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024, Colias Group, LLC

    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="shared-memory"><a class="header" href="#shared-memory">Shared Memory</a></h1>
<p>This chapter covers interacting with shared memory from protection domains written in Rust.
Navigate to and run the example:</p>
<pre><code>cd workspaces/microkit/shared-memory
make simulate
</code></pre>
<p>The example system description specifies two protection domains which share two memory regions:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/2064faa2051d897948c0fdc8517b7ff5595f7c90/workspaces/microkit/shared-memory/shared-memory.system#L7-L28">shared-memory.system:7:28</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-xml">&lt;system&gt;
    &lt;memory_region name="region_a" size="0x1_000" /&gt;

    &lt;memory_region name="region_b" size="0x1_000" /&gt;

    &lt;protection_domain name="client" priority="100"&gt;
        &lt;program_image path="microkit-shared-memory-client.elf" /&gt;
        &lt;map mr="region_a" vaddr="0x2_000_000" perms="rw" cached="true" setvar_vaddr="region_a_vaddr" /&gt;
        &lt;map mr="region_b" vaddr="0x2_400_000" perms="rw" cached="true" setvar_vaddr="region_b_vaddr" /&gt;
    &lt;/protection_domain&gt;

    &lt;protection_domain name="server" priority="200"&gt;
        &lt;program_image path="microkit-shared-memory-server.elf" /&gt;
        &lt;map mr="region_a" vaddr="0x2_000_000" perms="r" cached="true" setvar_vaddr="region_a_vaddr" /&gt;
        &lt;map mr="region_b" vaddr="0x2_400_000" perms="r" cached="true" setvar_vaddr="region_b_vaddr" /&gt;
    &lt;/protection_domain&gt;

    &lt;channel&gt;
        &lt;end pd="client" id="13" pp="true" /&gt;
        &lt;end pd="server" id="37" /&gt;
    &lt;/channel&gt;
&lt;/system&gt;

</code></pre>
</div>
</div>
<p>The Microkit tool will inject memory region virtual addresses into protection domain images according to the <code>setvar_vaddr</code> attribute values.
For example, the virtual address of the mapping of <code>region_a</code> into the <code>client</code> protection domain will be injected into the <code>microkit-shared-memory-client.elf</code> image at the location specified by then <code>region_a_vaddr</code> symbol.</p>
<p>In the case of Rust, declaring a symbol that the Microkit tool can patch requires a bit more intentionality than in the C case.
The <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/macro.var.html"><code>sel4_microkit::var!</code></a> macro is provided to declare such symbols.</p>
<p>The <code>var!</code> macro's <a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/src/sel4_microkit_base/symbols.rs.html#55-67">implementation</a> is just a few lines of code.
We want to express this symbol as a global variable that does not change at runtime, but which cannot be assumed to have the value we assign it at compile time, and which must not be optimized away.
The near-trivial
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_immutable_cell/struct.ImmutableCell.html"><code>sel4_immutable_cell::ImmutableCell</code></a> type encapsulates this pattern.
The <code>#[no_mangle]</code> attribute instructs the compiler to use the name of the variable as the name of the symbol.
This is the default in C, but not Rust.
We direct the compiler to put this symbol in the <code>.data</code> section with <code>#[link_section = ".data"]</code> to ensure that space is allocated for it in the ELF file itself, not just the program image it describes.</p>
<p>So far, the example protection domains just store pointers to the shared memory regions in their handler state:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/2064faa2051d897948c0fdc8517b7ff5595f7c90/workspaces/microkit/shared-memory/pds/client/src/main.rs#L17-L31">pds/client/src/main.rs:17:31</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn init() -&gt; impl Handler {
    debug_println!("client: initializing");

    let region_a = *var!(region_a_vaddr: usize = 0);
    let region_b = *var!(region_b_vaddr: usize = 0);

    debug_println!("client: region_a = {region_a:#x?}");
    debug_println!("client: region_b = {region_b:#x?}");

    let _ = SERVER.pp_call(MessageInfo::default());

    debug_println!("TEST_PASS");

    NullHandler::new()
}
</code></pre>
</div>
</div>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/2064faa2051d897948c0fdc8517b7ff5595f7c90/workspaces/microkit/shared-memory/pds/server/src/main.rs#L17-L46">pds/server/src/main.rs:17:46</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">fn init() -&gt; impl Handler {
    debug_println!("server: initializing");

    let region_a = *var!(region_a_vaddr: usize = 0);
    let region_b = *var!(region_b_vaddr: usize = 0);

    debug_println!("server: region_a = {region_a:#x?}");
    debug_println!("server: region_b = {region_b:#x?}");

    HandlerImpl { region_a, region_b }
}

struct HandlerImpl {
    region_a: usize,
    region_b: usize,
}

impl Handler for HandlerImpl {
    type Error = Infallible;

    fn protected(
        &amp;mut self,
        channel: Channel,
        _msg_info: MessageInfo,
    ) -&gt; Result&lt;MessageInfo, Self::Error&gt; {
        assert_eq!(channel, CLIENT);

        Ok(MessageInfo::default())
    }
}
</code></pre>
</div>
</div>
<h2 id="step-11a"><a class="header" href="#step-11a">Step 11.A   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('5e3db5a4dcd15f753d94c08b6900c2d1ab694a52')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/5e3db5a4dcd15f753d94c08b6900c2d1ab694a52"> <i class="fa fa-github"></i> </a></a></h2>
<p>Let's assign types to these shared memory regions.
We can define our types in a crate that both the client and server can use:</p>
<div class="fragment-with-gh-link">
<div class="fragment-with-gh-link-link">
<pre><code><a href="https://github.com/seL4/seL4-rust-tutorial-code/blob/5e3db5a4dcd15f753d94c08b6900c2d1ab694a52/workspaces/microkit/shared-memory/pds/common/src/lib.rs#L9-L18">pds/common/src/lib.rs:9:18</a></code></pre>
</div>
<div class="fragment-with-gh-link-fragment">
<pre><code class="language-rust ignore">use zerocopy::{FromBytes, IntoBytes};

pub const REGION_A_SIZE: usize = 1337;

#[repr(C)]
#[derive(IntoBytes, FromBytes)]
pub struct RegionB {
    pub field_1: u64,
    pub foo: [u16; 16],
}
</code></pre>
</div>
</div>
<p>Suppose <code>region_a: [u8; REGION_A_SIZE]</code> and <code>region_b: RegionB</code>.
You could just turn the virtual addresses we get in our <code>var!</code> symbols into pointers and start interacting with the shared memory regions with <code>unsafe</code> <code>ptr::*</code> operations, but we can leverage the Rust type system to come up with a solution that only requires <code>unsafe</code> at initialization time.</p>
<h2 id="step-11b"><a class="header" href="#step-11b">Step 11.B   <span class="step-heading-clickable" onclick="navigator.clipboard.writeText('d5e2458ae4c2eab978c8d6e5113e8fc3d1c32cb2')"> <i class="fa fa-copy"></i> </span><a class="step-heading-clickable" href="https://github.com/seL4/seL4-rust-tutorial-code/commit/d5e2458ae4c2eab978c8d6e5113e8fc3d1c32cb2"> <i class="fa fa-github"></i> </a></a></h2>
<p>The
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_shared_memory/index.html"><code>sel4-shared-memory</code></a>
crate provides a way for you to declare a memory region's type and bounds, along with the memory access operations that can safely be used on it, so that you can access it without <code>unsafe</code> code.
That initial declaration is, however, <code>unsafe</code>.</p>
<p>The
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_shared_memory/index.html"><code>sel4-shared-memory</code></a>
is a thin wrapper around the
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_shared_memory/index.html"><code>sel4_abstract_ptr</code></a>
crate, instantiating its abstract pointer types with memory access operations suitable for memory that is shared with another protection domain.</p>
<p>The
<a href="https://sel4.github.io/seL4-rust-tutorial/rustdoc/microkit/aarch64-sel4-microkit-unwind/doc/sel4_microkit/macro.memory_region_symbol.html"><code>sel4_microkit::memory_region_symbol!</code></a>
macro is like the <code>sel4_microkit::var!</code> macro, except specialized for shared memory region virtual address symbols.
For one, the underlying symbol is always of type <code>usize</code> and the macro returns a value of type <code>NonNull&lt;_&gt;</code>.
<code>memory_region_symbol!</code> has a few additional features.
For example, <code>memory_region_symbol!(foo: *mut [u8] n = BAR)</code> returns a <code>NonNull&lt;[u8]&gt;</code> with a runtime slice length of <code>BAR</code>.</p>
<p>See this step's diff for how to put this all together.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="assets/sel4-rust-tutorial.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
